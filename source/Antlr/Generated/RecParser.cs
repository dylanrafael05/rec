//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from source/Antlr/Rec.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class RecParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, Whitespace=14, SLComment=15, MLComment=16, 
		Var=17, Let=18, End=19, If=20, Else=21, While=22, Fn=23, Continue=24, 
		Break=25, Defer=26, Type=27, Struct=28, Template=29, New=30, Return=31, 
		For=32, Mod=33, Use=34, Auto=35, And=36, Not=37, Or=38, True=39, False=40, 
		Uninit=41, As=42, Identifier=43, Integer=44, Float=45, String=46, Plus=47, 
		Minus=48, Star=49, Slash=50, Ampersand=51, Equal=52, CompEqual=53, OpenParen=54, 
		CloseParen=55, OpenBrace=56, CloseBrace=57, OpenIndex=58, CloseIndex=59;
	public const int
		RULE_program = 0, RULE_topLevelStatement = 1, RULE_asStatement = 2, RULE_modStatement = 3, 
		RULE_useStatement = 4, RULE_templateHeader = 5, RULE_structFieldDefine = 6, 
		RULE_structDefine = 7, RULE_fnArgumentDefine = 8, RULE_fnDefine = 9, RULE_aliasDefine = 10, 
		RULE_block = 11, RULE_statement = 12, RULE_returnStmt = 13, RULE_deferStmt = 14, 
		RULE_ifStmt = 15, RULE_ifTail = 16, RULE_whileStmt = 17, RULE_assignStmt = 18, 
		RULE_letExpr = 19, RULE_letStmt = 20, RULE_typenameFnArgs = 21, RULE_typename = 22, 
		RULE_expr = 23, RULE_opExpr = 24, RULE_explicitTemplateInstatiation = 25, 
		RULE_callExpr = 26, RULE_structExpr = 27, RULE_structExprAssign = 28, 
		RULE_dotComponent = 29, RULE_dotExpr = 30, RULE_termExpr = 31, RULE_literal = 32, 
		RULE_boolLiteral = 33;
	public static readonly string[] ruleNames = {
		"program", "topLevelStatement", "asStatement", "modStatement", "useStatement", 
		"templateHeader", "structFieldDefine", "structDefine", "fnArgumentDefine", 
		"fnDefine", "aliasDefine", "block", "statement", "returnStmt", "deferStmt", 
		"ifStmt", "ifTail", "whileStmt", "assignStmt", "letExpr", "letStmt", "typenameFnArgs", 
		"typename", "expr", "opExpr", "explicitTemplateInstatiation", "callExpr", 
		"structExpr", "structExprAssign", "dotComponent", "dotExpr", "termExpr", 
		"literal", "boolLiteral"
	};

	private static readonly string[] _LiteralNames = {
		null, "'.'", "','", "';'", "'!='", "'>'", "'<'", "'<='", "'>='", "'|'", 
		"'>>'", "'<<'", "'~'", "'''", null, null, null, "'var'", "'let'", "'end'", 
		"'if'", "'else'", "'while'", "'fn'", "'continue'", "'break'", "'defer'", 
		"'type'", "'struct'", "'template'", "'new'", "'return'", "'for'", "'mod'", 
		"'use'", "'auto'", "'and'", "'not'", "'or'", "'true'", "'false'", "'uninit'", 
		"'as'", null, null, null, null, "'+'", "'-'", "'*'", "'/'", "'&'", "'='", 
		"'=='", "'('", "')'", "'{'", "'}'", "'['", "']'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, "Whitespace", "SLComment", "MLComment", "Var", "Let", "End", 
		"If", "Else", "While", "Fn", "Continue", "Break", "Defer", "Type", "Struct", 
		"Template", "New", "Return", "For", "Mod", "Use", "Auto", "And", "Not", 
		"Or", "True", "False", "Uninit", "As", "Identifier", "Integer", "Float", 
		"String", "Plus", "Minus", "Star", "Slash", "Ampersand", "Equal", "CompEqual", 
		"OpenParen", "CloseParen", "OpenBrace", "CloseBrace", "OpenIndex", "CloseIndex"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Rec.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static RecParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public RecParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public RecParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4424764620800L) != 0)) {
				{
				{
				State = 68;
				topLevelStatement();
				}
				}
				State = 73;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopLevelStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FnDefineContext fnDefine() {
			return GetRuleContext<FnDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDefineContext structDefine() {
			return GetRuleContext<StructDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasDefineContext aliasDefine() {
			return GetRuleContext<AliasDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetStmtContext letStmt() {
			return GetRuleContext<LetStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModStatementContext modStatement() {
			return GetRuleContext<ModStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsStatementContext asStatement() {
			return GetRuleContext<AsStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseStatementContext useStatement() {
			return GetRuleContext<UseStatementContext>(0);
		}
		public TopLevelStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topLevelStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTopLevelStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTopLevelStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTopLevelStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TopLevelStatementContext topLevelStatement() {
		TopLevelStatementContext _localctx = new TopLevelStatementContext(Context, State);
		EnterRule(_localctx, 2, RULE_topLevelStatement);
		try {
			State = 81;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 74;
				fnDefine();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 75;
				structDefine();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 76;
				aliasDefine();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 77;
				letStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 78;
				modStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 79;
				asStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 80;
				useStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] As() { return GetTokens(RecParser.As); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As(int i) {
			return GetToken(RecParser.As, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(RecParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		public AsStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAsStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAsStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AsStatementContext asStatement() {
		AsStatementContext _localctx = new AsStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_asStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 83;
			Match(As);
			State = 84;
			typename();
			State = 88;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Identifier) {
				{
				{
				State = 85;
				Match(Identifier);
				}
				}
				State = 90;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 94;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4424764620800L) != 0)) {
				{
				{
				State = 91;
				topLevelStatement();
				}
				}
				State = 96;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 97;
			Match(End);
			State = 98;
			Match(As);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModStatementContext : ParserRuleContext {
		public IToken _Identifier;
		public IList<IToken> _parts = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Mod() { return GetTokens(RecParser.Mod); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod(int i) {
			return GetToken(RecParser.Mod, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(RecParser.End, 0); }
		public ModStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterModStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitModStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModStatementContext modStatement() {
		ModStatementContext _localctx = new ModStatementContext(Context, State);
		EnterRule(_localctx, 6, RULE_modStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 100;
			Match(Mod);
			{
			State = 101;
			_localctx._Identifier = Match(Identifier);
			_localctx._parts.Add(_localctx._Identifier);
			State = 106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==T__0) {
				{
				{
				State = 102;
				Match(T__0);
				State = 103;
				_localctx._Identifier = Match(Identifier);
				_localctx._parts.Add(_localctx._Identifier);
				}
				}
				State = 108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			State = 112;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 109;
					topLevelStatement();
					}
					} 
				}
				State = 114;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			State = 117;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				{
				State = 115;
				Match(End);
				State = 116;
				Match(Mod);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseStatementContext : ParserRuleContext {
		public IToken _Identifier;
		public IList<IToken> _parts = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Use() { return GetToken(RecParser.Use, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		public UseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterUseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitUseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UseStatementContext useStatement() {
		UseStatementContext _localctx = new UseStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_useStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			Match(Use);
			{
			State = 120;
			_localctx._Identifier = Match(Identifier);
			_localctx._parts.Add(_localctx._Identifier);
			State = 125;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==T__0) {
				{
				{
				State = 121;
				Match(T__0);
				State = 122;
				_localctx._Identifier = Match(Identifier);
				_localctx._parts.Add(_localctx._Identifier);
				}
				}
				State = 127;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TemplateHeaderContext : ParserRuleContext {
		public IToken _Identifier;
		public IList<IToken> _args = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Template() { return GetToken(RecParser.Template, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		public TemplateHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_templateHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTemplateHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTemplateHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTemplateHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TemplateHeaderContext templateHeader() {
		TemplateHeaderContext _localctx = new TemplateHeaderContext(Context, State);
		EnterRule(_localctx, 10, RULE_templateHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128;
			Match(Template);
			State = 130;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 129;
				_localctx._Identifier = Match(Identifier);
				_localctx._args.Add(_localctx._Identifier);
				}
				}
				State = 132;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==Identifier );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldDefineContext : ParserRuleContext {
		public IToken name;
		public TypenameContext type;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public StructFieldDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structFieldDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructFieldDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructFieldDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructFieldDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldDefineContext structFieldDefine() {
		StructFieldDefineContext _localctx = new StructFieldDefineContext(Context, State);
		EnterRule(_localctx, 12, RULE_structFieldDefine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 134;
			_localctx.name = Match(Identifier);
			State = 135;
			_localctx.type = typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDefineContext : ParserRuleContext {
		public IToken name;
		public StructFieldDefineContext _structFieldDefine;
		public IList<StructFieldDefineContext> _fields = new List<StructFieldDefineContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(RecParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TemplateHeaderContext templateHeader() {
			return GetRuleContext<TemplateHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldDefineContext[] structFieldDefine() {
			return GetRuleContexts<StructFieldDefineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldDefineContext structFieldDefine(int i) {
			return GetRuleContext<StructFieldDefineContext>(i);
		}
		public StructDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDefineContext structDefine() {
		StructDefineContext _localctx = new StructDefineContext(Context, State);
		EnterRule(_localctx, 14, RULE_structDefine);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 138;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Template) {
				{
				State = 137;
				templateHeader();
				}
			}

			State = 140;
			Match(Struct);
			State = 141;
			_localctx.name = Match(Identifier);
			State = 142;
			Match(OpenBrace);
			State = 148;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,10,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 143;
					_localctx._structFieldDefine = structFieldDefine();
					_localctx._fields.Add(_localctx._structFieldDefine);
					State = 144;
					Match(T__1);
					}
					} 
				}
				State = 150;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,10,Context);
			}
			State = 155;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 151;
				_localctx._structFieldDefine = structFieldDefine();
				_localctx._fields.Add(_localctx._structFieldDefine);
				State = 153;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==T__1) {
					{
					State = 152;
					Match(T__1);
					}
				}

				}
			}

			State = 157;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FnArgumentDefineContext : ParserRuleContext {
		public IToken auto;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Auto() { return GetToken(RecParser.Auto, 0); }
		public FnArgumentDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fnArgumentDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterFnArgumentDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitFnArgumentDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFnArgumentDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FnArgumentDefineContext fnArgumentDefine() {
		FnArgumentDefineContext _localctx = new FnArgumentDefineContext(Context, State);
		EnterRule(_localctx, 16, RULE_fnArgumentDefine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 160;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Auto) {
				{
				State = 159;
				_localctx.auto = Match(Auto);
				}
			}

			State = 162;
			Match(Identifier);
			State = 163;
			typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FnDefineContext : ParserRuleContext {
		public IToken name;
		public FnArgumentDefineContext _fnArgumentDefine;
		public IList<FnArgumentDefineContext> _args = new List<FnArgumentDefineContext>();
		public TypenameContext ret;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fn() { return GetToken(RecParser.Fn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TemplateHeaderContext templateHeader() {
			return GetRuleContext<TemplateHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FnArgumentDefineContext[] fnArgumentDefine() {
			return GetRuleContexts<FnArgumentDefineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FnArgumentDefineContext fnArgumentDefine(int i) {
			return GetRuleContext<FnArgumentDefineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public FnDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fnDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterFnDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitFnDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFnDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FnDefineContext fnDefine() {
		FnDefineContext _localctx = new FnDefineContext(Context, State);
		EnterRule(_localctx, 18, RULE_fnDefine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 166;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Template) {
				{
				State = 165;
				templateHeader();
				}
			}

			State = 168;
			Match(Fn);
			State = 169;
			_localctx.name = Match(Identifier);
			State = 170;
			Match(OpenParen);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Auto || _la==Identifier) {
				{
				State = 171;
				_localctx._fnArgumentDefine = fnArgumentDefine();
				_localctx._args.Add(_localctx._fnArgumentDefine);
				State = 176;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==T__1) {
					{
					{
					State = 172;
					Match(T__1);
					State = 173;
					_localctx._fnArgumentDefine = fnArgumentDefine();
					_localctx._args.Add(_localctx._fnArgumentDefine);
					}
					}
					State = 178;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 181;
			Match(CloseParen);
			State = 183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 306816520716025856L) != 0)) {
				{
				State = 182;
				_localctx.ret = typename();
				}
			}

			State = 185;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasDefineContext : ParserRuleContext {
		public IToken name;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Type() { return GetToken(RecParser.Type, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		public AliasDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAliasDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAliasDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasDefineContext aliasDefine() {
		AliasDefineContext _localctx = new AliasDefineContext(Context, State);
		EnterRule(_localctx, 20, RULE_aliasDefine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 187;
			Match(Type);
			State = 188;
			_localctx.name = Match(Identifier);
			State = 189;
			Match(Equal);
			State = 190;
			typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public StatementContext _statement;
		public IList<StatementContext> _stmts = new List<StatementContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 22, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 192;
			Match(OpenBrace);
			State = 196;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 90627936458510336L) != 0)) {
				{
				{
				State = 193;
				_localctx._statement = statement();
				_localctx._stmts.Add(_localctx._statement);
				}
				}
				State = 198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 199;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignStmtContext assignStmt() {
			return GetRuleContext<AssignStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetStmtContext letStmt() {
			return GetRuleContext<LetStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhileStmtContext whileStmt() {
			return GetRuleContext<WhileStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferStmtContext deferStmt() {
			return GetRuleContext<DeferStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStmtContext returnStmt() {
			return GetRuleContext<ReturnStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(RecParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(RecParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 24, RULE_statement);
		try {
			State = 211;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 201;
				assignStmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 202;
				letStmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 203;
				ifStmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 204;
				whileStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 205;
				deferStmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 206;
				returnStmt();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 207;
				Match(Continue);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 208;
				Match(Break);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 209;
				block();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 210;
				expr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStmtContext : ParserRuleContext {
		public ExprContext value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(RecParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ReturnStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStmtContext returnStmt() {
		ReturnStmtContext _localctx = new ReturnStmtContext(Context, State);
		EnterRule(_localctx, 26, RULE_returnStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 213;
			Match(Return);
			State = 214;
			_localctx.value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Defer() { return GetToken(RecParser.Defer, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public DeferStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeferStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeferStmtContext deferStmt() {
		DeferStmtContext _localctx = new DeferStmtContext(Context, State);
		EnterRule(_localctx, 28, RULE_deferStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 216;
			Match(Defer);
			State = 217;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStmtContext : ParserRuleContext {
		public ExprContext cond;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(RecParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfTailContext ifTail() {
			return GetRuleContext<IfTailContext>(0);
		}
		public IfStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStmtContext ifStmt() {
		IfStmtContext _localctx = new IfStmtContext(Context, State);
		EnterRule(_localctx, 30, RULE_ifStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219;
			Match(If);
			State = 220;
			_localctx.cond = expr();
			State = 221;
			block();
			State = 223;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Else) {
				{
				State = 222;
				ifTail();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfTailContext : ParserRuleContext {
		public BlockContext end_block;
		public IfStmtContext elif;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(RecParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		public IfTailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifTail; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterIfTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitIfTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfTail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfTailContext ifTail() {
		IfTailContext _localctx = new IfTailContext(Context, State);
		EnterRule(_localctx, 32, RULE_ifTail);
		try {
			State = 229;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,21,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 225;
				Match(Else);
				State = 226;
				_localctx.end_block = block();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 227;
				Match(Else);
				State = 228;
				_localctx.elif = ifStmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStmtContext : ParserRuleContext {
		public ExprContext cond;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(RecParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public WhileStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStmtContext whileStmt() {
		WhileStmtContext _localctx = new WhileStmtContext(Context, State);
		EnterRule(_localctx, 34, RULE_whileStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231;
			Match(While);
			State = 232;
			_localctx.cond = expr();
			State = 233;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignStmtContext : ParserRuleContext {
		public ExprContext target;
		public ExprContext value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public AssignStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAssignStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAssignStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignStmtContext assignStmt() {
		AssignStmtContext _localctx = new AssignStmtContext(Context, State);
		EnterRule(_localctx, 36, RULE_assignStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235;
			_localctx.target = expr();
			State = 236;
			Match(Equal);
			State = 237;
			_localctx.value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Uninit() { return GetToken(RecParser.Uninit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public LetExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLetExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLetExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetExprContext letExpr() {
		LetExprContext _localctx = new LetExprContext(Context, State);
		EnterRule(_localctx, 38, RULE_letExpr);
		try {
			State = 241;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Uninit:
				EnterOuterAlt(_localctx, 1);
				{
				State = 239;
				Match(Uninit);
				}
				break;
			case T__11:
			case New:
			case Not:
			case True:
			case False:
			case Identifier:
			case Integer:
			case Float:
			case String:
			case Plus:
			case Minus:
			case OpenParen:
				EnterOuterAlt(_localctx, 2);
				{
				State = 240;
				expr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetStmtContext : ParserRuleContext {
		public IToken spec;
		public IToken target;
		public TypenameContext type;
		public LetExprContext value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LetExprContext letExpr() {
			return GetRuleContext<LetExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Let() { return GetToken(RecParser.Let, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(RecParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public LetStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLetStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLetStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetStmtContext letStmt() {
		LetStmtContext _localctx = new LetStmtContext(Context, State);
		EnterRule(_localctx, 40, RULE_letStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 243;
			_localctx.spec = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==Var || _la==Let) ) {
				_localctx.spec = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 244;
			_localctx.target = Match(Identifier);
			State = 246;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 306816520716025856L) != 0)) {
				{
				State = 245;
				_localctx.type = typename();
				}
			}

			State = 248;
			Match(Equal);
			State = 249;
			_localctx.value = letExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypenameFnArgsContext : ParserRuleContext {
		public TypenameContext type;
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		public TypenameFnArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typenameFnArgs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameFnArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameFnArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameFnArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypenameFnArgsContext typenameFnArgs() {
		TypenameFnArgsContext _localctx = new TypenameFnArgsContext(Context, State);
		EnterRule(_localctx, 42, RULE_typenameFnArgs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 252;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,24,Context) ) {
			case 1:
				{
				State = 251;
				Match(Identifier);
				}
				break;
			}
			State = 254;
			_localctx.type = typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypenameContext : ParserRuleContext {
		public TypenameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typename; } }
	 
		public TypenameContext() { }
		public virtual void CopyFrom(TypenameContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypenameManyContext : TypenameContext {
		public IToken _Identifier;
		public IList<IToken> _parts = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		public TypenameManyContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameMany(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameMany(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameMany(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameGenericContext : TypenameContext {
		public TypenameContext @base;
		public TypenameContext _typename;
		public IList<TypenameContext> _args = new List<TypenameContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext[] typename() {
			return GetRuleContexts<TypenameContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename(int i) {
			return GetRuleContext<TypenameContext>(i);
		}
		public TypenameGenericContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameGeneric(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameGeneric(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameGeneric(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameFnContext : TypenameContext {
		public TypenameFnArgsContext _typenameFnArgs;
		public IList<TypenameFnArgsContext> _args = new List<TypenameFnArgsContext>();
		public TypenameContext ret;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fn() { return GetToken(RecParser.Fn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameFnArgsContext[] typenameFnArgs() {
			return GetRuleContexts<TypenameFnArgsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameFnArgsContext typenameFnArgs(int i) {
			return GetRuleContext<TypenameFnArgsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenameFnContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameFn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameFn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameFn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameArrayContext : TypenameContext {
		public TypenameContext @base;
		public IToken count;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenIndex() { return GetToken(RecParser.OpenIndex, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseIndex() { return GetToken(RecParser.CloseIndex, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Integer() { return GetToken(RecParser.Integer, 0); }
		public TypenameArrayContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameArray(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameSingleContext : TypenameContext {
		public TypenameContext inner;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenameSingleContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameSingle(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenamePointerContext : TypenameContext {
		public TypenameContext @base;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenamePointerContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenamePointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenamePointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenamePointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypenameContext typename() {
		TypenameContext _localctx = new TypenameContext(Context, State);
		EnterRule(_localctx, 44, RULE_typename);
		int _la;
		try {
			int _alt;
			State = 303;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
			case 1:
				_localctx = new TypenameSingleContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 256;
				Match(Identifier);
				}
				break;
			case 2:
				_localctx = new TypenameSingleContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 257;
				Match(OpenParen);
				State = 258;
				((TypenameSingleContext)_localctx).inner = typename();
				State = 259;
				Match(CloseParen);
				}
				break;
			case 3:
				_localctx = new TypenameManyContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 261;
				((TypenameManyContext)_localctx)._Identifier = Match(Identifier);
				((TypenameManyContext)_localctx)._parts.Add(((TypenameManyContext)_localctx)._Identifier);
				State = 264;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 262;
						Match(T__0);
						State = 263;
						((TypenameManyContext)_localctx)._Identifier = Match(Identifier);
						((TypenameManyContext)_localctx)._parts.Add(((TypenameManyContext)_localctx)._Identifier);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 266;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,25,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case 4:
				_localctx = new TypenameGenericContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 268;
				Match(OpenParen);
				State = 269;
				((TypenameGenericContext)_localctx).@base = typename();
				State = 271;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 270;
					((TypenameGenericContext)_localctx)._typename = typename();
					((TypenameGenericContext)_localctx)._args.Add(((TypenameGenericContext)_localctx)._typename);
					}
					}
					State = 273;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 306816520716025856L) != 0) );
				State = 275;
				Match(CloseParen);
				}
				break;
			case 5:
				_localctx = new TypenamePointerContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 277;
				Match(Star);
				State = 278;
				((TypenamePointerContext)_localctx).@base = typename();
				}
				break;
			case 6:
				_localctx = new TypenameArrayContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 279;
				Match(OpenIndex);
				State = 280;
				((TypenameArrayContext)_localctx).@base = typename();
				State = 283;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==T__2) {
					{
					State = 281;
					Match(T__2);
					State = 282;
					((TypenameArrayContext)_localctx).count = Match(Integer);
					}
				}

				State = 285;
				Match(CloseIndex);
				}
				break;
			case 7:
				_localctx = new TypenameFnContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 287;
				Match(Fn);
				State = 288;
				Match(OpenParen);
				State = 297;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 306816520716025856L) != 0)) {
					{
					State = 289;
					((TypenameFnContext)_localctx)._typenameFnArgs = typenameFnArgs();
					((TypenameFnContext)_localctx)._args.Add(((TypenameFnContext)_localctx)._typenameFnArgs);
					State = 294;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==T__1) {
						{
						{
						State = 290;
						Match(T__1);
						State = 291;
						((TypenameFnContext)_localctx)._typenameFnArgs = typenameFnArgs();
						((TypenameFnContext)_localctx)._args.Add(((TypenameFnContext)_localctx)._typenameFnArgs);
						}
						}
						State = 296;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 299;
				Match(CloseParen);
				State = 301;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
				case 1:
					{
					State = 300;
					((TypenameFnContext)_localctx).ret = typename();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 46, RULE_expr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 305;
			opExpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpExprContext : ParserRuleContext {
		public OpExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opExpr; } }
	 
		public OpExprContext() { }
		public virtual void CopyFrom(OpExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AddExpressionContext : OpExprContext {
		public OpExprContext rhs;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(RecParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(RecParser.Minus, 0); }
		public AddExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAddExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAddExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicExpressionContext : OpExprContext {
		public OpExprContext lhs;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(RecParser.And, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(RecParser.Or, 0); }
		public LogicExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLogicExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLogicExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemoryExpressionContext : OpExprContext {
		public OpExprContext op;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(RecParser.Ampersand, 0); }
		public MemoryExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterMemoryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitMemoryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemoryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryExpressionContext : OpExprContext {
		public OpExprContext op;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(RecParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(RecParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(RecParser.Not, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		public UnaryExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompareExpressionContext : OpExprContext {
		public OpExprContext lhs;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CompEqual() { return GetToken(RecParser.CompEqual, 0); }
		public CompareExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCompareExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCompareExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompareExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CallExpressionContext : OpExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public CallExprContext callExpr() {
			return GetRuleContext<CallExprContext>(0);
		}
		public CallExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCallExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCallExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MulExpressionContext : OpExprContext {
		public OpExprContext lhs;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Slash() { return GetToken(RecParser.Slash, 0); }
		public MulExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterMulExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitMulExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitwiseExpressionContext : OpExprContext {
		public OpExprContext rhs;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(RecParser.Ampersand, 0); }
		public BitwiseExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBitwiseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBitwiseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpExprContext opExpr() {
		return opExpr(0);
	}

	private OpExprContext opExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		OpExprContext _localctx = new OpExprContext(Context, _parentState);
		OpExprContext _prevctx = _localctx;
		int _startState = 48;
		EnterRecursionRule(_localctx, 48, RULE_opExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 311;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case T__11:
			case Not:
			case Plus:
			case Minus:
				{
				_localctx = new UnaryExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 308;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 422349904023552L) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 309;
				((UnaryExpressionContext)_localctx).op = opExpr(3);
				}
				break;
			case New:
			case True:
			case False:
			case Identifier:
			case Integer:
			case Float:
			case String:
			case OpenParen:
				{
				_localctx = new CallExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 310;
				callExpr(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 332;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 330;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,33,Context) ) {
					case 1:
						{
						_localctx = new LogicExpressionContext(new OpExprContext(_parentctx, _parentState));
						((LogicExpressionContext)_localctx).lhs = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 313;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 314;
						_la = TokenStream.LA(1);
						if ( !(_la==And || _la==Or) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 315;
						((LogicExpressionContext)_localctx).lhs = opExpr(9);
						}
						break;
					case 2:
						{
						_localctx = new CompareExpressionContext(new OpExprContext(_parentctx, _parentState));
						((CompareExpressionContext)_localctx).lhs = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 316;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 317;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 9007199254741488L) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 318;
						((CompareExpressionContext)_localctx).lhs = opExpr(8);
						}
						break;
					case 3:
						{
						_localctx = new MulExpressionContext(new OpExprContext(_parentctx, _parentState));
						((MulExpressionContext)_localctx).lhs = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 319;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 320;
						_la = TokenStream.LA(1);
						if ( !(_la==Star || _la==Slash) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 321;
						((MulExpressionContext)_localctx).lhs = opExpr(7);
						}
						break;
					case 4:
						{
						_localctx = new BitwiseExpressionContext(new OpExprContext(_parentctx, _parentState));
						((BitwiseExpressionContext)_localctx).rhs = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 322;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 323;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 2251799813688832L) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 324;
						((BitwiseExpressionContext)_localctx).rhs = opExpr(6);
						}
						break;
					case 5:
						{
						_localctx = new AddExpressionContext(new OpExprContext(_parentctx, _parentState));
						((AddExpressionContext)_localctx).rhs = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 325;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 326;
						_la = TokenStream.LA(1);
						if ( !(_la==Plus || _la==Minus) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 327;
						((AddExpressionContext)_localctx).rhs = opExpr(5);
						}
						break;
					case 6:
						{
						_localctx = new MemoryExpressionContext(new OpExprContext(_parentctx, _parentState));
						((MemoryExpressionContext)_localctx).op = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 328;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 329;
						_la = TokenStream.LA(1);
						if ( !(_la==Star || _la==Ampersand) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					}
					} 
				}
				State = 334;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,34,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExplicitTemplateInstatiationContext : ParserRuleContext {
		public TypenameContext _typename;
		public IList<TypenameContext> _args = new List<TypenameContext>();
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext[] typename() {
			return GetRuleContexts<TypenameContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename(int i) {
			return GetRuleContext<TypenameContext>(i);
		}
		public ExplicitTemplateInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explicitTemplateInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterExplicitTemplateInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitExplicitTemplateInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplicitTemplateInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExplicitTemplateInstatiationContext explicitTemplateInstatiation() {
		ExplicitTemplateInstatiationContext _localctx = new ExplicitTemplateInstatiationContext(Context, State);
		EnterRule(_localctx, 50, RULE_explicitTemplateInstatiation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 335;
			Match(T__12);
			State = 339;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 306816520716025856L) != 0)) {
				{
				{
				State = 336;
				_localctx._typename = typename();
				_localctx._args.Add(_localctx._typename);
				}
				}
				State = 341;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 342;
			Match(T__12);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallExprContext : ParserRuleContext {
		public CallExprContext target;
		public ExplicitTemplateInstatiationContext inst;
		public ExprContext _expr;
		public IList<ExprContext> _args = new List<ExprContext>();
		[System.Diagnostics.DebuggerNonUserCode] public DotExprContext dotExpr() {
			return GetRuleContext<DotExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CallExprContext callExpr() {
			return GetRuleContext<CallExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTemplateInstatiationContext explicitTemplateInstatiation() {
			return GetRuleContext<ExplicitTemplateInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public CallExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCallExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCallExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallExprContext callExpr() {
		return callExpr(0);
	}

	private CallExprContext callExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		CallExprContext _localctx = new CallExprContext(Context, _parentState);
		CallExprContext _prevctx = _localctx;
		int _startState = 52;
		EnterRecursionRule(_localctx, 52, RULE_callExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 345;
			dotExpr(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 365;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new CallExprContext(_parentctx, _parentState);
					_localctx.target = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_callExpr);
					State = 347;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 349;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==T__12) {
						{
						State = 348;
						_localctx.inst = explicitTemplateInstatiation();
						}
					}

					State = 351;
					Match(OpenParen);
					State = 360;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 18570340150022144L) != 0)) {
						{
						State = 352;
						_localctx._expr = expr();
						_localctx._args.Add(_localctx._expr);
						State = 357;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==T__1) {
							{
							{
							State = 353;
							Match(T__1);
							State = 354;
							_localctx._expr = expr();
							_localctx._args.Add(_localctx._expr);
							}
							}
							State = 359;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
					}

					State = 362;
					Match(CloseParen);
					}
					} 
				}
				State = 367;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructExprContext : ParserRuleContext {
		public StructExprAssignContext _structExprAssign;
		public IList<StructExprAssignContext> _parts = new List<StructExprAssignContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode New() { return GetToken(RecParser.New, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructExprAssignContext[] structExprAssign() {
			return GetRuleContexts<StructExprAssignContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructExprAssignContext structExprAssign(int i) {
			return GetRuleContext<StructExprAssignContext>(i);
		}
		public StructExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructExprContext structExpr() {
		StructExprContext _localctx = new StructExprContext(Context, State);
		EnterRule(_localctx, 54, RULE_structExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 368;
			Match(New);
			State = 369;
			typename();
			State = 370;
			Match(OpenBrace);
			State = 372;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 371;
				_localctx._structExprAssign = structExprAssign();
				_localctx._parts.Add(_localctx._structExprAssign);
				}
				}
				State = 374;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==Identifier );
			State = 376;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprAssignContext : ParserRuleContext {
		public IToken Field;
		public ExprContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StructExprAssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprAssign; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructExprAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructExprAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructExprAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructExprAssignContext structExprAssign() {
		StructExprAssignContext _localctx = new StructExprAssignContext(Context, State);
		EnterRule(_localctx, 56, RULE_structExprAssign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 378;
			_localctx.Field = Match(Identifier);
			State = 379;
			Match(Equal);
			State = 380;
			_localctx.Value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotComponentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RecParser.As, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public DotComponentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotComponent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDotComponent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDotComponent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDotComponent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DotComponentContext dotComponent() {
		DotComponentContext _localctx = new DotComponentContext(Context, State);
		EnterRule(_localctx, 58, RULE_dotComponent);
		try {
			State = 386;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 382;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 383;
				Match(Identifier);
				State = 384;
				Match(As);
				State = 385;
				typename();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotExprContext : ParserRuleContext {
		public DotComponentContext Field;
		[System.Diagnostics.DebuggerNonUserCode] public TermExprContext termExpr() {
			return GetRuleContext<TermExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotExprContext dotExpr() {
			return GetRuleContext<DotExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotComponentContext dotComponent() {
			return GetRuleContext<DotComponentContext>(0);
		}
		public DotExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDotExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDotExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDotExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DotExprContext dotExpr() {
		return dotExpr(0);
	}

	private DotExprContext dotExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DotExprContext _localctx = new DotExprContext(Context, _parentState);
		DotExprContext _prevctx = _localctx;
		int _startState = 60;
		EnterRecursionRule(_localctx, 60, RULE_dotExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 389;
			termExpr();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 396;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,42,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DotExprContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_dotExpr);
					State = 391;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 392;
					Match(T__0);
					State = 393;
					_localctx.Field = dotComponent();
					}
					} 
				}
				State = 398;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,42,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TermExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RecParser.As, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructExprContext structExpr() {
			return GetRuleContext<StructExprContext>(0);
		}
		public TermExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_termExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTermExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTermExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTermExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermExprContext termExpr() {
		TermExprContext _localctx = new TermExprContext(Context, State);
		EnterRule(_localctx, 62, RULE_termExpr);
		try {
			State = 409;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,43,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 399;
				literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 400;
				Match(Identifier);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 401;
				Match(Identifier);
				State = 402;
				Match(As);
				State = 403;
				typename();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 404;
				Match(OpenParen);
				State = 405;
				expr();
				State = 406;
				Match(CloseParen);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 408;
				structExpr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Integer() { return GetToken(RecParser.Integer, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(RecParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(RecParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BoolLiteralContext boolLiteral() {
			return GetRuleContext<BoolLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 64, RULE_literal);
		try {
			State = 415;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Integer:
				EnterOuterAlt(_localctx, 1);
				{
				State = 411;
				Match(Integer);
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 2);
				{
				State = 412;
				Match(Float);
				}
				break;
			case String:
				EnterOuterAlt(_localctx, 3);
				{
				State = 413;
				Match(String);
				}
				break;
			case True:
			case False:
				EnterOuterAlt(_localctx, 4);
				{
				State = 414;
				boolLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode True() { return GetToken(RecParser.True, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode False() { return GetToken(RecParser.False, 0); }
		public BoolLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBoolLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBoolLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolLiteralContext boolLiteral() {
		BoolLiteralContext _localctx = new BoolLiteralContext(Context, State);
		EnterRule(_localctx, 66, RULE_boolLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 417;
			_la = TokenStream.LA(1);
			if ( !(_la==True || _la==False) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 24: return opExpr_sempred((OpExprContext)_localctx, predIndex);
		case 26: return callExpr_sempred((CallExprContext)_localctx, predIndex);
		case 30: return dotExpr_sempred((DotExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool opExpr_sempred(OpExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 8);
		case 1: return Precpred(Context, 7);
		case 2: return Precpred(Context, 6);
		case 3: return Precpred(Context, 5);
		case 4: return Precpred(Context, 4);
		case 5: return Precpred(Context, 2);
		}
		return true;
	}
	private bool callExpr_sempred(CallExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 2);
		}
		return true;
	}
	private bool dotExpr_sempred(DotExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(Context, 2);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,59,420,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,1,0,5,0,70,8,0,10,0,
		12,0,73,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,82,8,1,1,2,1,2,1,2,5,2,87,
		8,2,10,2,12,2,90,9,2,1,2,5,2,93,8,2,10,2,12,2,96,9,2,1,2,1,2,1,2,1,3,1,
		3,1,3,1,3,5,3,105,8,3,10,3,12,3,108,9,3,1,3,5,3,111,8,3,10,3,12,3,114,
		9,3,1,3,1,3,3,3,118,8,3,1,4,1,4,1,4,1,4,5,4,124,8,4,10,4,12,4,127,9,4,
		1,5,1,5,4,5,131,8,5,11,5,12,5,132,1,6,1,6,1,6,1,7,3,7,139,8,7,1,7,1,7,
		1,7,1,7,1,7,1,7,5,7,147,8,7,10,7,12,7,150,9,7,1,7,1,7,3,7,154,8,7,3,7,
		156,8,7,1,7,1,7,1,8,3,8,161,8,8,1,8,1,8,1,8,1,9,3,9,167,8,9,1,9,1,9,1,
		9,1,9,1,9,1,9,5,9,175,8,9,10,9,12,9,178,9,9,3,9,180,8,9,1,9,1,9,3,9,184,
		8,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,11,1,11,5,11,195,8,11,10,11,12,
		11,198,9,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,
		3,12,212,8,12,1,13,1,13,1,13,1,14,1,14,1,14,1,15,1,15,1,15,1,15,3,15,224,
		8,15,1,16,1,16,1,16,1,16,3,16,230,8,16,1,17,1,17,1,17,1,17,1,18,1,18,1,
		18,1,18,1,19,1,19,3,19,242,8,19,1,20,1,20,1,20,3,20,247,8,20,1,20,1,20,
		1,20,1,21,3,21,253,8,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,
		22,4,22,265,8,22,11,22,12,22,266,1,22,1,22,1,22,4,22,272,8,22,11,22,12,
		22,273,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,284,8,22,1,22,1,22,
		1,22,1,22,1,22,1,22,1,22,5,22,293,8,22,10,22,12,22,296,9,22,3,22,298,8,
		22,1,22,1,22,3,22,302,8,22,3,22,304,8,22,1,23,1,23,1,24,1,24,1,24,1,24,
		3,24,312,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,
		24,1,24,1,24,1,24,1,24,1,24,5,24,331,8,24,10,24,12,24,334,9,24,1,25,1,
		25,5,25,338,8,25,10,25,12,25,341,9,25,1,25,1,25,1,26,1,26,1,26,1,26,1,
		26,3,26,350,8,26,1,26,1,26,1,26,1,26,5,26,356,8,26,10,26,12,26,359,9,26,
		3,26,361,8,26,1,26,5,26,364,8,26,10,26,12,26,367,9,26,1,27,1,27,1,27,1,
		27,4,27,373,8,27,11,27,12,27,374,1,27,1,27,1,28,1,28,1,28,1,28,1,29,1,
		29,1,29,1,29,3,29,387,8,29,1,30,1,30,1,30,1,30,1,30,1,30,5,30,395,8,30,
		10,30,12,30,398,9,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,
		3,31,410,8,31,1,32,1,32,1,32,1,32,3,32,416,8,32,1,33,1,33,1,33,0,3,48,
		52,60,34,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,
		44,46,48,50,52,54,56,58,60,62,64,66,0,9,1,0,17,18,3,0,12,12,37,37,47,48,
		2,0,36,36,38,38,2,0,4,8,53,53,1,0,49,50,2,0,9,11,51,51,1,0,47,48,2,0,49,
		49,51,51,1,0,39,40,457,0,71,1,0,0,0,2,81,1,0,0,0,4,83,1,0,0,0,6,100,1,
		0,0,0,8,119,1,0,0,0,10,128,1,0,0,0,12,134,1,0,0,0,14,138,1,0,0,0,16,160,
		1,0,0,0,18,166,1,0,0,0,20,187,1,0,0,0,22,192,1,0,0,0,24,211,1,0,0,0,26,
		213,1,0,0,0,28,216,1,0,0,0,30,219,1,0,0,0,32,229,1,0,0,0,34,231,1,0,0,
		0,36,235,1,0,0,0,38,241,1,0,0,0,40,243,1,0,0,0,42,252,1,0,0,0,44,303,1,
		0,0,0,46,305,1,0,0,0,48,311,1,0,0,0,50,335,1,0,0,0,52,344,1,0,0,0,54,368,
		1,0,0,0,56,378,1,0,0,0,58,386,1,0,0,0,60,388,1,0,0,0,62,409,1,0,0,0,64,
		415,1,0,0,0,66,417,1,0,0,0,68,70,3,2,1,0,69,68,1,0,0,0,70,73,1,0,0,0,71,
		69,1,0,0,0,71,72,1,0,0,0,72,1,1,0,0,0,73,71,1,0,0,0,74,82,3,18,9,0,75,
		82,3,14,7,0,76,82,3,20,10,0,77,82,3,40,20,0,78,82,3,6,3,0,79,82,3,4,2,
		0,80,82,3,8,4,0,81,74,1,0,0,0,81,75,1,0,0,0,81,76,1,0,0,0,81,77,1,0,0,
		0,81,78,1,0,0,0,81,79,1,0,0,0,81,80,1,0,0,0,82,3,1,0,0,0,83,84,5,42,0,
		0,84,88,3,44,22,0,85,87,5,43,0,0,86,85,1,0,0,0,87,90,1,0,0,0,88,86,1,0,
		0,0,88,89,1,0,0,0,89,94,1,0,0,0,90,88,1,0,0,0,91,93,3,2,1,0,92,91,1,0,
		0,0,93,96,1,0,0,0,94,92,1,0,0,0,94,95,1,0,0,0,95,97,1,0,0,0,96,94,1,0,
		0,0,97,98,5,19,0,0,98,99,5,42,0,0,99,5,1,0,0,0,100,101,5,33,0,0,101,106,
		5,43,0,0,102,103,5,1,0,0,103,105,5,43,0,0,104,102,1,0,0,0,105,108,1,0,
		0,0,106,104,1,0,0,0,106,107,1,0,0,0,107,112,1,0,0,0,108,106,1,0,0,0,109,
		111,3,2,1,0,110,109,1,0,0,0,111,114,1,0,0,0,112,110,1,0,0,0,112,113,1,
		0,0,0,113,117,1,0,0,0,114,112,1,0,0,0,115,116,5,19,0,0,116,118,5,33,0,
		0,117,115,1,0,0,0,117,118,1,0,0,0,118,7,1,0,0,0,119,120,5,34,0,0,120,125,
		5,43,0,0,121,122,5,1,0,0,122,124,5,43,0,0,123,121,1,0,0,0,124,127,1,0,
		0,0,125,123,1,0,0,0,125,126,1,0,0,0,126,9,1,0,0,0,127,125,1,0,0,0,128,
		130,5,29,0,0,129,131,5,43,0,0,130,129,1,0,0,0,131,132,1,0,0,0,132,130,
		1,0,0,0,132,133,1,0,0,0,133,11,1,0,0,0,134,135,5,43,0,0,135,136,3,44,22,
		0,136,13,1,0,0,0,137,139,3,10,5,0,138,137,1,0,0,0,138,139,1,0,0,0,139,
		140,1,0,0,0,140,141,5,28,0,0,141,142,5,43,0,0,142,148,5,56,0,0,143,144,
		3,12,6,0,144,145,5,2,0,0,145,147,1,0,0,0,146,143,1,0,0,0,147,150,1,0,0,
		0,148,146,1,0,0,0,148,149,1,0,0,0,149,155,1,0,0,0,150,148,1,0,0,0,151,
		153,3,12,6,0,152,154,5,2,0,0,153,152,1,0,0,0,153,154,1,0,0,0,154,156,1,
		0,0,0,155,151,1,0,0,0,155,156,1,0,0,0,156,157,1,0,0,0,157,158,5,57,0,0,
		158,15,1,0,0,0,159,161,5,35,0,0,160,159,1,0,0,0,160,161,1,0,0,0,161,162,
		1,0,0,0,162,163,5,43,0,0,163,164,3,44,22,0,164,17,1,0,0,0,165,167,3,10,
		5,0,166,165,1,0,0,0,166,167,1,0,0,0,167,168,1,0,0,0,168,169,5,23,0,0,169,
		170,5,43,0,0,170,179,5,54,0,0,171,176,3,16,8,0,172,173,5,2,0,0,173,175,
		3,16,8,0,174,172,1,0,0,0,175,178,1,0,0,0,176,174,1,0,0,0,176,177,1,0,0,
		0,177,180,1,0,0,0,178,176,1,0,0,0,179,171,1,0,0,0,179,180,1,0,0,0,180,
		181,1,0,0,0,181,183,5,55,0,0,182,184,3,44,22,0,183,182,1,0,0,0,183,184,
		1,0,0,0,184,185,1,0,0,0,185,186,3,22,11,0,186,19,1,0,0,0,187,188,5,27,
		0,0,188,189,5,43,0,0,189,190,5,52,0,0,190,191,3,44,22,0,191,21,1,0,0,0,
		192,196,5,56,0,0,193,195,3,24,12,0,194,193,1,0,0,0,195,198,1,0,0,0,196,
		194,1,0,0,0,196,197,1,0,0,0,197,199,1,0,0,0,198,196,1,0,0,0,199,200,5,
		57,0,0,200,23,1,0,0,0,201,212,3,36,18,0,202,212,3,40,20,0,203,212,3,30,
		15,0,204,212,3,34,17,0,205,212,3,28,14,0,206,212,3,26,13,0,207,212,5,24,
		0,0,208,212,5,25,0,0,209,212,3,22,11,0,210,212,3,46,23,0,211,201,1,0,0,
		0,211,202,1,0,0,0,211,203,1,0,0,0,211,204,1,0,0,0,211,205,1,0,0,0,211,
		206,1,0,0,0,211,207,1,0,0,0,211,208,1,0,0,0,211,209,1,0,0,0,211,210,1,
		0,0,0,212,25,1,0,0,0,213,214,5,31,0,0,214,215,3,46,23,0,215,27,1,0,0,0,
		216,217,5,26,0,0,217,218,3,22,11,0,218,29,1,0,0,0,219,220,5,20,0,0,220,
		221,3,46,23,0,221,223,3,22,11,0,222,224,3,32,16,0,223,222,1,0,0,0,223,
		224,1,0,0,0,224,31,1,0,0,0,225,226,5,21,0,0,226,230,3,22,11,0,227,228,
		5,21,0,0,228,230,3,30,15,0,229,225,1,0,0,0,229,227,1,0,0,0,230,33,1,0,
		0,0,231,232,5,22,0,0,232,233,3,46,23,0,233,234,3,22,11,0,234,35,1,0,0,
		0,235,236,3,46,23,0,236,237,5,52,0,0,237,238,3,46,23,0,238,37,1,0,0,0,
		239,242,5,41,0,0,240,242,3,46,23,0,241,239,1,0,0,0,241,240,1,0,0,0,242,
		39,1,0,0,0,243,244,7,0,0,0,244,246,5,43,0,0,245,247,3,44,22,0,246,245,
		1,0,0,0,246,247,1,0,0,0,247,248,1,0,0,0,248,249,5,52,0,0,249,250,3,38,
		19,0,250,41,1,0,0,0,251,253,5,43,0,0,252,251,1,0,0,0,252,253,1,0,0,0,253,
		254,1,0,0,0,254,255,3,44,22,0,255,43,1,0,0,0,256,304,5,43,0,0,257,258,
		5,54,0,0,258,259,3,44,22,0,259,260,5,55,0,0,260,304,1,0,0,0,261,264,5,
		43,0,0,262,263,5,1,0,0,263,265,5,43,0,0,264,262,1,0,0,0,265,266,1,0,0,
		0,266,264,1,0,0,0,266,267,1,0,0,0,267,304,1,0,0,0,268,269,5,54,0,0,269,
		271,3,44,22,0,270,272,3,44,22,0,271,270,1,0,0,0,272,273,1,0,0,0,273,271,
		1,0,0,0,273,274,1,0,0,0,274,275,1,0,0,0,275,276,5,55,0,0,276,304,1,0,0,
		0,277,278,5,49,0,0,278,304,3,44,22,0,279,280,5,58,0,0,280,283,3,44,22,
		0,281,282,5,3,0,0,282,284,5,44,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,
		285,1,0,0,0,285,286,5,59,0,0,286,304,1,0,0,0,287,288,5,23,0,0,288,297,
		5,54,0,0,289,294,3,42,21,0,290,291,5,2,0,0,291,293,3,42,21,0,292,290,1,
		0,0,0,293,296,1,0,0,0,294,292,1,0,0,0,294,295,1,0,0,0,295,298,1,0,0,0,
		296,294,1,0,0,0,297,289,1,0,0,0,297,298,1,0,0,0,298,299,1,0,0,0,299,301,
		5,55,0,0,300,302,3,44,22,0,301,300,1,0,0,0,301,302,1,0,0,0,302,304,1,0,
		0,0,303,256,1,0,0,0,303,257,1,0,0,0,303,261,1,0,0,0,303,268,1,0,0,0,303,
		277,1,0,0,0,303,279,1,0,0,0,303,287,1,0,0,0,304,45,1,0,0,0,305,306,3,48,
		24,0,306,47,1,0,0,0,307,308,6,24,-1,0,308,309,7,1,0,0,309,312,3,48,24,
		3,310,312,3,52,26,0,311,307,1,0,0,0,311,310,1,0,0,0,312,332,1,0,0,0,313,
		314,10,8,0,0,314,315,7,2,0,0,315,331,3,48,24,9,316,317,10,7,0,0,317,318,
		7,3,0,0,318,331,3,48,24,8,319,320,10,6,0,0,320,321,7,4,0,0,321,331,3,48,
		24,7,322,323,10,5,0,0,323,324,7,5,0,0,324,331,3,48,24,6,325,326,10,4,0,
		0,326,327,7,6,0,0,327,331,3,48,24,5,328,329,10,2,0,0,329,331,7,7,0,0,330,
		313,1,0,0,0,330,316,1,0,0,0,330,319,1,0,0,0,330,322,1,0,0,0,330,325,1,
		0,0,0,330,328,1,0,0,0,331,334,1,0,0,0,332,330,1,0,0,0,332,333,1,0,0,0,
		333,49,1,0,0,0,334,332,1,0,0,0,335,339,5,13,0,0,336,338,3,44,22,0,337,
		336,1,0,0,0,338,341,1,0,0,0,339,337,1,0,0,0,339,340,1,0,0,0,340,342,1,
		0,0,0,341,339,1,0,0,0,342,343,5,13,0,0,343,51,1,0,0,0,344,345,6,26,-1,
		0,345,346,3,60,30,0,346,365,1,0,0,0,347,349,10,2,0,0,348,350,3,50,25,0,
		349,348,1,0,0,0,349,350,1,0,0,0,350,351,1,0,0,0,351,360,5,54,0,0,352,357,
		3,46,23,0,353,354,5,2,0,0,354,356,3,46,23,0,355,353,1,0,0,0,356,359,1,
		0,0,0,357,355,1,0,0,0,357,358,1,0,0,0,358,361,1,0,0,0,359,357,1,0,0,0,
		360,352,1,0,0,0,360,361,1,0,0,0,361,362,1,0,0,0,362,364,5,55,0,0,363,347,
		1,0,0,0,364,367,1,0,0,0,365,363,1,0,0,0,365,366,1,0,0,0,366,53,1,0,0,0,
		367,365,1,0,0,0,368,369,5,30,0,0,369,370,3,44,22,0,370,372,5,56,0,0,371,
		373,3,56,28,0,372,371,1,0,0,0,373,374,1,0,0,0,374,372,1,0,0,0,374,375,
		1,0,0,0,375,376,1,0,0,0,376,377,5,57,0,0,377,55,1,0,0,0,378,379,5,43,0,
		0,379,380,5,52,0,0,380,381,3,46,23,0,381,57,1,0,0,0,382,387,5,43,0,0,383,
		384,5,43,0,0,384,385,5,42,0,0,385,387,3,44,22,0,386,382,1,0,0,0,386,383,
		1,0,0,0,387,59,1,0,0,0,388,389,6,30,-1,0,389,390,3,62,31,0,390,396,1,0,
		0,0,391,392,10,2,0,0,392,393,5,1,0,0,393,395,3,58,29,0,394,391,1,0,0,0,
		395,398,1,0,0,0,396,394,1,0,0,0,396,397,1,0,0,0,397,61,1,0,0,0,398,396,
		1,0,0,0,399,410,3,64,32,0,400,410,5,43,0,0,401,402,5,43,0,0,402,403,5,
		42,0,0,403,410,3,44,22,0,404,405,5,54,0,0,405,406,3,46,23,0,406,407,5,
		55,0,0,407,410,1,0,0,0,408,410,3,54,27,0,409,399,1,0,0,0,409,400,1,0,0,
		0,409,401,1,0,0,0,409,404,1,0,0,0,409,408,1,0,0,0,410,63,1,0,0,0,411,416,
		5,44,0,0,412,416,5,45,0,0,413,416,5,46,0,0,414,416,3,66,33,0,415,411,1,
		0,0,0,415,412,1,0,0,0,415,413,1,0,0,0,415,414,1,0,0,0,416,65,1,0,0,0,417,
		418,7,8,0,0,418,67,1,0,0,0,45,71,81,88,94,106,112,117,125,132,138,148,
		153,155,160,166,176,179,183,196,211,223,229,241,246,252,266,273,283,294,
		297,301,303,311,330,332,339,349,357,360,365,374,386,396,409,415
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
