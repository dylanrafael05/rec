//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from source/Antlr/Rec.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class RecParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, Whitespace=14, SLComment=15, MLComment=16, 
		Var=17, Let=18, End=19, If=20, Else=21, While=22, Fn=23, Continue=24, 
		Break=25, Defer=26, Type=27, Struct=28, Template=29, New=30, Return=31, 
		For=32, Mod=33, Use=34, Auto=35, And=36, Not=37, Or=38, True=39, False=40, 
		Uninit=41, As=42, Cast=43, Identifier=44, Integer=45, Float=46, String=47, 
		Plus=48, Minus=49, Star=50, Slash=51, Ampersand=52, Equal=53, CompEqual=54, 
		OpenParen=55, CloseParen=56, OpenBrace=57, CloseBrace=58, OpenIndex=59, 
		CloseIndex=60;
	public const int
		RULE_program = 0, RULE_topLevelStatement = 1, RULE_asStatement = 2, RULE_simpleScopedIdentifier = 3, 
		RULE_modStatement = 4, RULE_useStatement = 5, RULE_templateHeader = 6, 
		RULE_structFieldDefine = 7, RULE_structDefine = 8, RULE_fnArgumentDefine = 9, 
		RULE_fnDefine = 10, RULE_aliasDefine = 11, RULE_block = 12, RULE_statement = 13, 
		RULE_returnStmt = 14, RULE_deferStmt = 15, RULE_ifStmt = 16, RULE_ifTail = 17, 
		RULE_whileStmt = 18, RULE_assignStmt = 19, RULE_letExpr = 20, RULE_letStmt = 21, 
		RULE_typenameFnArgs = 22, RULE_typename = 23, RULE_expr = 24, RULE_opExpr = 25, 
		RULE_castExpr = 26, RULE_explicitTemplateInstatiation = 27, RULE_callExpr = 28, 
		RULE_structExpr = 29, RULE_structExprAssign = 30, RULE_dotComponent = 31, 
		RULE_dotExpr = 32, RULE_termExpr = 33, RULE_literal = 34, RULE_boolLiteral = 35;
	public static readonly string[] ruleNames = {
		"program", "topLevelStatement", "asStatement", "simpleScopedIdentifier", 
		"modStatement", "useStatement", "templateHeader", "structFieldDefine", 
		"structDefine", "fnArgumentDefine", "fnDefine", "aliasDefine", "block", 
		"statement", "returnStmt", "deferStmt", "ifStmt", "ifTail", "whileStmt", 
		"assignStmt", "letExpr", "letStmt", "typenameFnArgs", "typename", "expr", 
		"opExpr", "castExpr", "explicitTemplateInstatiation", "callExpr", "structExpr", 
		"structExprAssign", "dotComponent", "dotExpr", "termExpr", "literal", 
		"boolLiteral"
	};

	private static readonly string[] _LiteralNames = {
		null, "'.'", "','", "';'", "'!='", "'>'", "'<'", "'<='", "'>='", "'|'", 
		"'>>'", "'<<'", "'~'", "'''", null, null, null, "'var'", "'let'", "'end'", 
		"'if'", "'else'", "'while'", "'fn'", "'continue'", "'break'", "'defer'", 
		"'type'", "'struct'", "'template'", "'new'", "'return'", "'for'", "'mod'", 
		"'use'", "'auto'", "'and'", "'not'", "'or'", "'true'", "'false'", "'uninit'", 
		"'as'", "'cast'", null, null, null, null, "'+'", "'-'", "'*'", "'/'", 
		"'&'", "'='", "'=='", "'('", "')'", "'{'", "'}'", "'['", "']'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, "Whitespace", "SLComment", "MLComment", "Var", "Let", "End", 
		"If", "Else", "While", "Fn", "Continue", "Break", "Defer", "Type", "Struct", 
		"Template", "New", "Return", "For", "Mod", "Use", "Auto", "And", "Not", 
		"Or", "True", "False", "Uninit", "As", "Cast", "Identifier", "Integer", 
		"Float", "String", "Plus", "Minus", "Star", "Slash", "Ampersand", "Equal", 
		"CompEqual", "OpenParen", "CloseParen", "OpenBrace", "CloseBrace", "OpenIndex", 
		"CloseIndex"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Rec.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static RecParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public RecParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public RecParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 75;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4424764620800L) != 0)) {
				{
				{
				State = 72;
				topLevelStatement();
				}
				}
				State = 77;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopLevelStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FnDefineContext fnDefine() {
			return GetRuleContext<FnDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructDefineContext structDefine() {
			return GetRuleContext<StructDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AliasDefineContext aliasDefine() {
			return GetRuleContext<AliasDefineContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetStmtContext letStmt() {
			return GetRuleContext<LetStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ModStatementContext modStatement() {
			return GetRuleContext<ModStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AsStatementContext asStatement() {
			return GetRuleContext<AsStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseStatementContext useStatement() {
			return GetRuleContext<UseStatementContext>(0);
		}
		public TopLevelStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topLevelStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTopLevelStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTopLevelStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTopLevelStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TopLevelStatementContext topLevelStatement() {
		TopLevelStatementContext _localctx = new TopLevelStatementContext(Context, State);
		EnterRule(_localctx, 2, RULE_topLevelStatement);
		try {
			State = 85;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 78;
				fnDefine();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 79;
				structDefine();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 80;
				aliasDefine();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 81;
				letStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 82;
				modStatement();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 83;
				asStatement();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 84;
				useStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] As() { return GetTokens(RecParser.As); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As(int i) {
			return GetToken(RecParser.As, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(RecParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		public AsStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAsStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAsStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAsStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AsStatementContext asStatement() {
		AsStatementContext _localctx = new AsStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_asStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87;
			Match(As);
			State = 88;
			typename();
			State = 92;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Identifier) {
				{
				{
				State = 89;
				Match(Identifier);
				}
				}
				State = 94;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 98;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4424764620800L) != 0)) {
				{
				{
				State = 95;
				topLevelStatement();
				}
				}
				State = 100;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 101;
			Match(End);
			State = 102;
			Match(As);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleScopedIdentifierContext : ParserRuleContext {
		public IToken _Identifier;
		public IList<IToken> _Parts = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		public SimpleScopedIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleScopedIdentifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterSimpleScopedIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitSimpleScopedIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleScopedIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleScopedIdentifierContext simpleScopedIdentifier() {
		SimpleScopedIdentifierContext _localctx = new SimpleScopedIdentifierContext(Context, State);
		EnterRule(_localctx, 6, RULE_simpleScopedIdentifier);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 104;
			_localctx._Identifier = Match(Identifier);
			_localctx._Parts.Add(_localctx._Identifier);
			State = 109;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 105;
					Match(T__0);
					State = 106;
					_localctx._Identifier = Match(Identifier);
					_localctx._Parts.Add(_localctx._Identifier);
					}
					} 
				}
				State = 111;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,4,Context);
			}
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ModStatementContext : ParserRuleContext {
		public SimpleScopedIdentifierContext ModuleIdent;
		public TopLevelStatementContext _topLevelStatement;
		public IList<TopLevelStatementContext> _Substatements = new List<TopLevelStatementContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Mod() { return GetTokens(RecParser.Mod); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Mod(int i) {
			return GetToken(RecParser.Mod, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SimpleScopedIdentifierContext simpleScopedIdentifier() {
			return GetRuleContext<SimpleScopedIdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode End() { return GetToken(RecParser.End, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext[] topLevelStatement() {
			return GetRuleContexts<TopLevelStatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopLevelStatementContext topLevelStatement(int i) {
			return GetRuleContext<TopLevelStatementContext>(i);
		}
		public ModStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterModStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitModStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ModStatementContext modStatement() {
		ModStatementContext _localctx = new ModStatementContext(Context, State);
		EnterRule(_localctx, 8, RULE_modStatement);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(Mod);
			State = 113;
			_localctx.ModuleIdent = simpleScopedIdentifier();
			State = 117;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 114;
					_localctx._topLevelStatement = topLevelStatement();
					_localctx._Substatements.Add(_localctx._topLevelStatement);
					}
					} 
				}
				State = 119;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,5,Context);
			}
			State = 122;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,6,Context) ) {
			case 1:
				{
				State = 120;
				Match(End);
				State = 121;
				Match(Mod);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseStatementContext : ParserRuleContext {
		public SimpleScopedIdentifierContext Ident;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Use() { return GetToken(RecParser.Use, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SimpleScopedIdentifierContext simpleScopedIdentifier() {
			return GetRuleContext<SimpleScopedIdentifierContext>(0);
		}
		public UseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterUseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitUseStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UseStatementContext useStatement() {
		UseStatementContext _localctx = new UseStatementContext(Context, State);
		EnterRule(_localctx, 10, RULE_useStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			Match(Use);
			State = 125;
			_localctx.Ident = simpleScopedIdentifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TemplateHeaderContext : ParserRuleContext {
		public IToken _Identifier;
		public IList<IToken> _Args = new List<IToken>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Template() { return GetToken(RecParser.Template, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Identifier() { return GetTokens(RecParser.Identifier); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier(int i) {
			return GetToken(RecParser.Identifier, i);
		}
		public TemplateHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_templateHeader; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTemplateHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTemplateHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTemplateHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TemplateHeaderContext templateHeader() {
		TemplateHeaderContext _localctx = new TemplateHeaderContext(Context, State);
		EnterRule(_localctx, 12, RULE_templateHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 127;
			Match(Template);
			State = 129;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 128;
				_localctx._Identifier = Match(Identifier);
				_localctx._Args.Add(_localctx._Identifier);
				}
				}
				State = 131;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==Identifier );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructFieldDefineContext : ParserRuleContext {
		public IToken Name;
		public TypenameContext FieldType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public StructFieldDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structFieldDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructFieldDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructFieldDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructFieldDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructFieldDefineContext structFieldDefine() {
		StructFieldDefineContext _localctx = new StructFieldDefineContext(Context, State);
		EnterRule(_localctx, 14, RULE_structFieldDefine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 133;
			_localctx.Name = Match(Identifier);
			State = 134;
			_localctx.FieldType = typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructDefineContext : ParserRuleContext {
		public IToken Name;
		public StructFieldDefineContext _structFieldDefine;
		public IList<StructFieldDefineContext> _Fields = new List<StructFieldDefineContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Struct() { return GetToken(RecParser.Struct, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TemplateHeaderContext templateHeader() {
			return GetRuleContext<TemplateHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldDefineContext[] structFieldDefine() {
			return GetRuleContexts<StructFieldDefineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructFieldDefineContext structFieldDefine(int i) {
			return GetRuleContext<StructFieldDefineContext>(i);
		}
		public StructDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructDefineContext structDefine() {
		StructDefineContext _localctx = new StructDefineContext(Context, State);
		EnterRule(_localctx, 16, RULE_structDefine);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 137;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Template) {
				{
				State = 136;
				templateHeader();
				}
			}

			State = 139;
			Match(Struct);
			State = 140;
			_localctx.Name = Match(Identifier);
			State = 141;
			Match(OpenBrace);
			State = 147;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 142;
					_localctx._structFieldDefine = structFieldDefine();
					_localctx._Fields.Add(_localctx._structFieldDefine);
					State = 143;
					Match(T__1);
					}
					} 
				}
				State = 149;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,9,Context);
			}
			State = 154;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 150;
				_localctx._structFieldDefine = structFieldDefine();
				_localctx._Fields.Add(_localctx._structFieldDefine);
				State = 152;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==T__1) {
					{
					State = 151;
					Match(T__1);
					}
				}

				}
			}

			State = 156;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FnArgumentDefineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public FnArgumentDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fnArgumentDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterFnArgumentDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitFnArgumentDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFnArgumentDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FnArgumentDefineContext fnArgumentDefine() {
		FnArgumentDefineContext _localctx = new FnArgumentDefineContext(Context, State);
		EnterRule(_localctx, 18, RULE_fnArgumentDefine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158;
			Match(Identifier);
			State = 159;
			typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FnDefineContext : ParserRuleContext {
		public IToken Name;
		public FnArgumentDefineContext _fnArgumentDefine;
		public IList<FnArgumentDefineContext> _Args = new List<FnArgumentDefineContext>();
		public TypenameContext Ret;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fn() { return GetToken(RecParser.Fn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TemplateHeaderContext templateHeader() {
			return GetRuleContext<TemplateHeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FnArgumentDefineContext[] fnArgumentDefine() {
			return GetRuleContexts<FnArgumentDefineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FnArgumentDefineContext fnArgumentDefine(int i) {
			return GetRuleContext<FnArgumentDefineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public FnDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fnDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterFnDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitFnDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFnDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FnDefineContext fnDefine() {
		FnDefineContext _localctx = new FnDefineContext(Context, State);
		EnterRule(_localctx, 20, RULE_fnDefine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 162;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Template) {
				{
				State = 161;
				templateHeader();
				}
			}

			State = 164;
			Match(Fn);
			State = 165;
			_localctx.Name = Match(Identifier);
			State = 166;
			Match(OpenParen);
			State = 175;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Identifier) {
				{
				State = 167;
				_localctx._fnArgumentDefine = fnArgumentDefine();
				_localctx._Args.Add(_localctx._fnArgumentDefine);
				State = 172;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==T__1) {
					{
					{
					State = 168;
					Match(T__1);
					State = 169;
					_localctx._fnArgumentDefine = fnArgumentDefine();
					_localctx._Args.Add(_localctx._fnArgumentDefine);
					}
					}
					State = 174;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 177;
			Match(CloseParen);
			State = 179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 613633041423663104L) != 0)) {
				{
				State = 178;
				_localctx.Ret = typename();
				}
			}

			State = 181;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasDefineContext : ParserRuleContext {
		public IToken Name;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Type() { return GetToken(RecParser.Type, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		public AliasDefineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasDefine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAliasDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAliasDefine(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasDefine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasDefineContext aliasDefine() {
		AliasDefineContext _localctx = new AliasDefineContext(Context, State);
		EnterRule(_localctx, 22, RULE_aliasDefine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 183;
			Match(Type);
			State = 184;
			_localctx.Name = Match(Identifier);
			State = 185;
			Match(Equal);
			State = 186;
			typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public StatementContext _statement;
		public IList<StatementContext> _Statements = new List<StatementContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(Context, State);
		EnterRule(_localctx, 24, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 188;
			Match(OpenBrace);
			State = 192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 181254082866319360L) != 0)) {
				{
				{
				State = 189;
				_localctx._statement = statement();
				_localctx._Statements.Add(_localctx._statement);
				}
				}
				State = 194;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 195;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignStmtContext assignStmt() {
			return GetRuleContext<AssignStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetStmtContext letStmt() {
			return GetRuleContext<LetStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhileStmtContext whileStmt() {
			return GetRuleContext<WhileStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeferStmtContext deferStmt() {
			return GetRuleContext<DeferStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnStmtContext returnStmt() {
			return GetRuleContext<ReturnStmtContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Continue() { return GetToken(RecParser.Continue, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Break() { return GetToken(RecParser.Break, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 26, RULE_statement);
		try {
			State = 207;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 197;
				assignStmt();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 198;
				letStmt();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 199;
				ifStmt();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 200;
				whileStmt();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 201;
				deferStmt();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 202;
				returnStmt();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 203;
				Match(Continue);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 204;
				Match(Break);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 205;
				block();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 206;
				expr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnStmtContext : ParserRuleContext {
		public ExprContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Return() { return GetToken(RecParser.Return, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public ReturnStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitReturnStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnStmtContext returnStmt() {
		ReturnStmtContext _localctx = new ReturnStmtContext(Context, State);
		EnterRule(_localctx, 28, RULE_returnStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 209;
			Match(Return);
			State = 210;
			_localctx.Value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeferStmtContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Defer() { return GetToken(RecParser.Defer, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public DeferStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deferStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDeferStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeferStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeferStmtContext deferStmt() {
		DeferStmtContext _localctx = new DeferStmtContext(Context, State);
		EnterRule(_localctx, 30, RULE_deferStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212;
			Match(Defer);
			State = 213;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStmtContext : ParserRuleContext {
		public ExprContext Cond;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode If() { return GetToken(RecParser.If, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfTailContext ifTail() {
			return GetRuleContext<IfTailContext>(0);
		}
		public IfStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitIfStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStmtContext ifStmt() {
		IfStmtContext _localctx = new IfStmtContext(Context, State);
		EnterRule(_localctx, 32, RULE_ifStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 215;
			Match(If);
			State = 216;
			_localctx.Cond = expr();
			State = 217;
			block();
			State = 219;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==Else) {
				{
				State = 218;
				ifTail();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfTailContext : ParserRuleContext {
		public BlockContext EndBlock;
		public IfStmtContext Elif;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Else() { return GetToken(RecParser.Else, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IfStmtContext ifStmt() {
			return GetRuleContext<IfStmtContext>(0);
		}
		public IfTailContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifTail; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterIfTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitIfTail(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfTail(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfTailContext ifTail() {
		IfTailContext _localctx = new IfTailContext(Context, State);
		EnterRule(_localctx, 34, RULE_ifTail);
		try {
			State = 225;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,19,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 221;
				Match(Else);
				State = 222;
				_localctx.EndBlock = block();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 223;
				Match(Else);
				State = 224;
				_localctx.Elif = ifStmt();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhileStmtContext : ParserRuleContext {
		public ExprContext Cond;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode While() { return GetToken(RecParser.While, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public WhileStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whileStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitWhileStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhileStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhileStmtContext whileStmt() {
		WhileStmtContext _localctx = new WhileStmtContext(Context, State);
		EnterRule(_localctx, 36, RULE_whileStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 227;
			Match(While);
			State = 228;
			_localctx.Cond = expr();
			State = 229;
			block();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignStmtContext : ParserRuleContext {
		public ExprContext Target;
		public ExprContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public AssignStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAssignStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAssignStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignStmtContext assignStmt() {
		AssignStmtContext _localctx = new AssignStmtContext(Context, State);
		EnterRule(_localctx, 38, RULE_assignStmt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231;
			_localctx.Target = expr();
			State = 232;
			Match(Equal);
			State = 233;
			_localctx.Value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Uninit() { return GetToken(RecParser.Uninit, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public LetExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLetExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLetExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetExprContext letExpr() {
		LetExprContext _localctx = new LetExprContext(Context, State);
		EnterRule(_localctx, 40, RULE_letExpr);
		try {
			State = 237;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Uninit:
				EnterOuterAlt(_localctx, 1);
				{
				State = 235;
				Match(Uninit);
				}
				break;
			case T__11:
			case New:
			case Not:
			case True:
			case False:
			case Identifier:
			case Integer:
			case Float:
			case String:
			case Plus:
			case Minus:
			case OpenParen:
				EnterOuterAlt(_localctx, 2);
				{
				State = 236;
				expr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetStmtContext : ParserRuleContext {
		public IToken spec;
		public IToken Target;
		public TypenameContext VarType;
		public LetExprContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LetExprContext letExpr() {
			return GetRuleContext<LetExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Let() { return GetToken(RecParser.Let, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Var() { return GetToken(RecParser.Var, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public LetStmtContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letStmt; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLetStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLetStmt(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetStmt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetStmtContext letStmt() {
		LetStmtContext _localctx = new LetStmtContext(Context, State);
		EnterRule(_localctx, 42, RULE_letStmt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 239;
			_localctx.spec = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==Var || _la==Let) ) {
				_localctx.spec = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 240;
			_localctx.Target = Match(Identifier);
			State = 242;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 613633041423663104L) != 0)) {
				{
				State = 241;
				_localctx.VarType = typename();
				}
			}

			State = 244;
			Match(Equal);
			State = 245;
			_localctx.Value = letExpr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypenameFnArgsContext : ParserRuleContext {
		public TypenameContext ArgType;
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		public TypenameFnArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typenameFnArgs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameFnArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameFnArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameFnArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypenameFnArgsContext typenameFnArgs() {
		TypenameFnArgsContext _localctx = new TypenameFnArgsContext(Context, State);
		EnterRule(_localctx, 44, RULE_typenameFnArgs);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 248;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,22,Context) ) {
			case 1:
				{
				State = 247;
				Match(Identifier);
				}
				break;
			}
			State = 250;
			_localctx.ArgType = typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypenameContext : ParserRuleContext {
		public TypenameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typename; } }
	 
		public TypenameContext() { }
		public virtual void CopyFrom(TypenameContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypenameWrappedContext : TypenameContext {
		public TypenameContext Inner;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenameWrappedContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameWrapped(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameWrapped(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameWrapped(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameGenericContext : TypenameContext {
		public TypenameContext Base;
		public TypenameContext _typename;
		public IList<TypenameContext> _Args = new List<TypenameContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext[] typename() {
			return GetRuleContexts<TypenameContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename(int i) {
			return GetRuleContext<TypenameContext>(i);
		}
		public TypenameGenericContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameGeneric(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameGeneric(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameGeneric(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameFnContext : TypenameContext {
		public TypenameFnArgsContext _typenameFnArgs;
		public IList<TypenameFnArgsContext> _Args = new List<TypenameFnArgsContext>();
		public TypenameContext Ret;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Fn() { return GetToken(RecParser.Fn, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameFnArgsContext[] typenameFnArgs() {
			return GetRuleContexts<TypenameFnArgsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameFnArgsContext typenameFnArgs(int i) {
			return GetRuleContext<TypenameFnArgsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenameFnContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameFn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameFn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameFn(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameArrayContext : TypenameContext {
		public TypenameContext Base;
		public IToken Count;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenIndex() { return GetToken(RecParser.OpenIndex, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseIndex() { return GetToken(RecParser.CloseIndex, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Integer() { return GetToken(RecParser.Integer, 0); }
		public TypenameArrayContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameArray(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameArray(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenameSingleContext : TypenameContext {
		public SimpleScopedIdentifierContext Ident;
		[System.Diagnostics.DebuggerNonUserCode] public SimpleScopedIdentifierContext simpleScopedIdentifier() {
			return GetRuleContext<SimpleScopedIdentifierContext>(0);
		}
		public TypenameSingleContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenameSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenameSingle(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenameSingle(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TypenamePointerContext : TypenameContext {
		public TypenameContext Base;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public TypenamePointerContext(TypenameContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTypenamePointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTypenamePointer(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypenamePointer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypenameContext typename() {
		TypenameContext _localctx = new TypenameContext(Context, State);
		EnterRule(_localctx, 46, RULE_typename);
		int _la;
		try {
			State = 292;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				_localctx = new TypenameSingleContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 252;
				((TypenameSingleContext)_localctx).Ident = simpleScopedIdentifier();
				}
				break;
			case 2:
				_localctx = new TypenameWrappedContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 253;
				Match(OpenParen);
				State = 254;
				((TypenameWrappedContext)_localctx).Inner = typename();
				State = 255;
				Match(CloseParen);
				}
				break;
			case 3:
				_localctx = new TypenameGenericContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 257;
				Match(OpenParen);
				State = 258;
				((TypenameGenericContext)_localctx).Base = typename();
				State = 260;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 259;
					((TypenameGenericContext)_localctx)._typename = typename();
					((TypenameGenericContext)_localctx)._Args.Add(((TypenameGenericContext)_localctx)._typename);
					}
					}
					State = 262;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 613633041423663104L) != 0) );
				State = 264;
				Match(CloseParen);
				}
				break;
			case 4:
				_localctx = new TypenamePointerContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 266;
				Match(Star);
				State = 267;
				((TypenamePointerContext)_localctx).Base = typename();
				}
				break;
			case 5:
				_localctx = new TypenameArrayContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 268;
				Match(OpenIndex);
				State = 269;
				((TypenameArrayContext)_localctx).Base = typename();
				State = 272;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==T__2) {
					{
					State = 270;
					Match(T__2);
					State = 271;
					((TypenameArrayContext)_localctx).Count = Match(Integer);
					}
				}

				State = 274;
				Match(CloseIndex);
				}
				break;
			case 6:
				_localctx = new TypenameFnContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 276;
				Match(Fn);
				State = 277;
				Match(OpenParen);
				State = 286;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 613633041423663104L) != 0)) {
					{
					State = 278;
					((TypenameFnContext)_localctx)._typenameFnArgs = typenameFnArgs();
					((TypenameFnContext)_localctx)._Args.Add(((TypenameFnContext)_localctx)._typenameFnArgs);
					State = 283;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==T__1) {
						{
						{
						State = 279;
						Match(T__1);
						State = 280;
						((TypenameFnContext)_localctx)._typenameFnArgs = typenameFnArgs();
						((TypenameFnContext)_localctx)._Args.Add(((TypenameFnContext)_localctx)._typenameFnArgs);
						}
						}
						State = 285;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 288;
				Match(CloseParen);
				State = 290;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,27,Context) ) {
				case 1:
					{
					State = 289;
					((TypenameFnContext)_localctx).Ret = typename();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		public ExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExprContext expr() {
		ExprContext _localctx = new ExprContext(Context, State);
		EnterRule(_localctx, 48, RULE_expr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 294;
			opExpr(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpExprContext : ParserRuleContext {
		public OpExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opExpr; } }
	 
		public OpExprContext() { }
		public virtual void CopyFrom(OpExprContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AddExpressionContext : OpExprContext {
		public OpExprContext LHS;
		public OpExprContext RHS;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(RecParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(RecParser.Minus, 0); }
		public AddExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterAddExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitAddExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LogicExpressionContext : OpExprContext {
		public OpExprContext LHS;
		public OpExprContext RHS;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(RecParser.And, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(RecParser.Or, 0); }
		public LogicExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLogicExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLogicExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogicExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MemoryExpressionContext : OpExprContext {
		public OpExprContext Operand;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(RecParser.Ampersand, 0); }
		public MemoryExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterMemoryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitMemoryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMemoryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryExpressionContext : OpExprContext {
		public OpExprContext Operand;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Plus() { return GetToken(RecParser.Plus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Minus() { return GetToken(RecParser.Minus, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Not() { return GetToken(RecParser.Not, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr() {
			return GetRuleContext<OpExprContext>(0);
		}
		public UnaryExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CastExpressionContext : OpExprContext {
		[System.Diagnostics.DebuggerNonUserCode] public CastExprContext castExpr() {
			return GetRuleContext<CastExprContext>(0);
		}
		public CastExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCastExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompareExpressionContext : OpExprContext {
		public OpExprContext LHS;
		public OpExprContext RHS;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CompEqual() { return GetToken(RecParser.CompEqual, 0); }
		public CompareExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCompareExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCompareExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompareExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MulExpressionContext : OpExprContext {
		public OpExprContext LHS;
		public OpExprContext RHS;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Star() { return GetToken(RecParser.Star, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Slash() { return GetToken(RecParser.Slash, 0); }
		public MulExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterMulExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitMulExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BitwiseExpressionContext : OpExprContext {
		public OpExprContext LHS;
		public OpExprContext RHS;
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext[] opExpr() {
			return GetRuleContexts<OpExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OpExprContext opExpr(int i) {
			return GetRuleContext<OpExprContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ampersand() { return GetToken(RecParser.Ampersand, 0); }
		public BitwiseExpressionContext(OpExprContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBitwiseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBitwiseExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBitwiseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpExprContext opExpr() {
		return opExpr(0);
	}

	private OpExprContext opExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		OpExprContext _localctx = new OpExprContext(Context, _parentState);
		OpExprContext _prevctx = _localctx;
		int _startState = 50;
		EnterRecursionRule(_localctx, 50, RULE_opExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 300;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case T__11:
			case Not:
			case Plus:
			case Minus:
				{
				_localctx = new UnaryExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 297;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 844562369089536L) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 298;
				((UnaryExpressionContext)_localctx).Operand = opExpr(3);
				}
				break;
			case New:
			case True:
			case False:
			case Identifier:
			case Integer:
			case Float:
			case String:
			case OpenParen:
				{
				_localctx = new CastExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 299;
				castExpr();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 321;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 319;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,30,Context) ) {
					case 1:
						{
						_localctx = new LogicExpressionContext(new OpExprContext(_parentctx, _parentState));
						((LogicExpressionContext)_localctx).LHS = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 302;
						if (!(Precpred(Context, 8))) throw new FailedPredicateException(this, "Precpred(Context, 8)");
						State = 303;
						_la = TokenStream.LA(1);
						if ( !(_la==And || _la==Or) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 304;
						((LogicExpressionContext)_localctx).RHS = opExpr(9);
						}
						break;
					case 2:
						{
						_localctx = new CompareExpressionContext(new OpExprContext(_parentctx, _parentState));
						((CompareExpressionContext)_localctx).LHS = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 305;
						if (!(Precpred(Context, 7))) throw new FailedPredicateException(this, "Precpred(Context, 7)");
						State = 306;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 18014398509482480L) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 307;
						((CompareExpressionContext)_localctx).RHS = opExpr(8);
						}
						break;
					case 3:
						{
						_localctx = new MulExpressionContext(new OpExprContext(_parentctx, _parentState));
						((MulExpressionContext)_localctx).LHS = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 308;
						if (!(Precpred(Context, 6))) throw new FailedPredicateException(this, "Precpred(Context, 6)");
						State = 309;
						_la = TokenStream.LA(1);
						if ( !(_la==Star || _la==Slash) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 310;
						((MulExpressionContext)_localctx).RHS = opExpr(7);
						}
						break;
					case 4:
						{
						_localctx = new BitwiseExpressionContext(new OpExprContext(_parentctx, _parentState));
						((BitwiseExpressionContext)_localctx).LHS = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 311;
						if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
						State = 312;
						_la = TokenStream.LA(1);
						if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 4503599627374080L) != 0)) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 313;
						((BitwiseExpressionContext)_localctx).RHS = opExpr(6);
						}
						break;
					case 5:
						{
						_localctx = new AddExpressionContext(new OpExprContext(_parentctx, _parentState));
						((AddExpressionContext)_localctx).LHS = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 314;
						if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
						State = 315;
						_la = TokenStream.LA(1);
						if ( !(_la==Plus || _la==Minus) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						State = 316;
						((AddExpressionContext)_localctx).RHS = opExpr(5);
						}
						break;
					case 6:
						{
						_localctx = new MemoryExpressionContext(new OpExprContext(_parentctx, _parentState));
						((MemoryExpressionContext)_localctx).Operand = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_opExpr);
						State = 317;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 318;
						_la = TokenStream.LA(1);
						if ( !(_la==Star || _la==Ampersand) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
						break;
					}
					} 
				}
				State = 323;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,31,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class CastExprContext : ParserRuleContext {
		public CallExprContext Operand;
		public TypenameContext TargetType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Cast() { return GetToken(RecParser.Cast, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CallExprContext callExpr() {
			return GetRuleContext<CallExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public CastExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_castExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCastExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCastExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCastExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CastExprContext castExpr() {
		CastExprContext _localctx = new CastExprContext(Context, State);
		EnterRule(_localctx, 52, RULE_castExpr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 324;
			_localctx.Operand = callExpr(0);
			State = 325;
			Match(Cast);
			State = 326;
			_localctx.TargetType = typename();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExplicitTemplateInstatiationContext : ParserRuleContext {
		public TypenameContext _typename;
		public IList<TypenameContext> _args = new List<TypenameContext>();
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext[] typename() {
			return GetRuleContexts<TypenameContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename(int i) {
			return GetRuleContext<TypenameContext>(i);
		}
		public ExplicitTemplateInstatiationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explicitTemplateInstatiation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterExplicitTemplateInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitExplicitTemplateInstatiation(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplicitTemplateInstatiation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExplicitTemplateInstatiationContext explicitTemplateInstatiation() {
		ExplicitTemplateInstatiationContext _localctx = new ExplicitTemplateInstatiationContext(Context, State);
		EnterRule(_localctx, 54, RULE_explicitTemplateInstatiation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 328;
			Match(T__12);
			State = 332;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 613633041423663104L) != 0)) {
				{
				{
				State = 329;
				_localctx._typename = typename();
				_localctx._args.Add(_localctx._typename);
				}
				}
				State = 334;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 335;
			Match(T__12);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallExprContext : ParserRuleContext {
		public CallExprContext Target;
		public ExplicitTemplateInstatiationContext TemplateInst;
		public ExprContext _expr;
		public IList<ExprContext> _args = new List<ExprContext>();
		[System.Diagnostics.DebuggerNonUserCode] public DotExprContext dotExpr() {
			return GetRuleContext<DotExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CallExprContext callExpr() {
			return GetRuleContext<CallExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExplicitTemplateInstatiationContext explicitTemplateInstatiation() {
			return GetRuleContext<ExplicitTemplateInstatiationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext[] expr() {
			return GetRuleContexts<ExprContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr(int i) {
			return GetRuleContext<ExprContext>(i);
		}
		public CallExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterCallExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitCallExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallExprContext callExpr() {
		return callExpr(0);
	}

	private CallExprContext callExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		CallExprContext _localctx = new CallExprContext(Context, _parentState);
		CallExprContext _prevctx = _localctx;
		int _startState = 56;
		EnterRecursionRule(_localctx, 56, RULE_callExpr, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 338;
			dotExpr(0);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 358;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new CallExprContext(_parentctx, _parentState);
					_localctx.Target = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_callExpr);
					State = 340;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 342;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==T__12) {
						{
						State = 341;
						_localctx.TemplateInst = explicitTemplateInstatiation();
						}
					}

					State = 344;
					Match(OpenParen);
					State = 353;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 37138892519903232L) != 0)) {
						{
						State = 345;
						_localctx._expr = expr();
						_localctx._args.Add(_localctx._expr);
						State = 350;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==T__1) {
							{
							{
							State = 346;
							Match(T__1);
							State = 347;
							_localctx._expr = expr();
							_localctx._args.Add(_localctx._expr);
							}
							}
							State = 352;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
					}

					State = 355;
					Match(CloseParen);
					}
					} 
				}
				State = 360;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,36,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class StructExprContext : ParserRuleContext {
		public StructExprAssignContext _structExprAssign;
		public IList<StructExprAssignContext> _parts = new List<StructExprAssignContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode New() { return GetToken(RecParser.New, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenBrace() { return GetToken(RecParser.OpenBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseBrace() { return GetToken(RecParser.CloseBrace, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructExprAssignContext[] structExprAssign() {
			return GetRuleContexts<StructExprAssignContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StructExprAssignContext structExprAssign(int i) {
			return GetRuleContext<StructExprAssignContext>(i);
		}
		public StructExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructExprContext structExpr() {
		StructExprContext _localctx = new StructExprContext(Context, State);
		EnterRule(_localctx, 58, RULE_structExpr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 361;
			Match(New);
			State = 362;
			typename();
			State = 363;
			Match(OpenBrace);
			State = 365;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 364;
				_localctx._structExprAssign = structExprAssign();
				_localctx._parts.Add(_localctx._structExprAssign);
				}
				}
				State = 367;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==Identifier );
			State = 369;
			Match(CloseBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StructExprAssignContext : ParserRuleContext {
		public IToken Field;
		public ExprContext Value;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Equal() { return GetToken(RecParser.Equal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		public StructExprAssignContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_structExprAssign; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterStructExprAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitStructExprAssign(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStructExprAssign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StructExprAssignContext structExprAssign() {
		StructExprAssignContext _localctx = new StructExprAssignContext(Context, State);
		EnterRule(_localctx, 60, RULE_structExprAssign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 371;
			_localctx.Field = Match(Identifier);
			State = 372;
			Match(Equal);
			State = 373;
			_localctx.Value = expr();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotComponentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RecParser.As, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		public DotComponentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotComponent; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDotComponent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDotComponent(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDotComponent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DotComponentContext dotComponent() {
		DotComponentContext _localctx = new DotComponentContext(Context, State);
		EnterRule(_localctx, 62, RULE_dotComponent);
		try {
			State = 379;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,38,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 375;
				Match(Identifier);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 376;
				Match(Identifier);
				State = 377;
				Match(As);
				State = 378;
				typename();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotExprContext : ParserRuleContext {
		public DotComponentContext Field;
		[System.Diagnostics.DebuggerNonUserCode] public TermExprContext termExpr() {
			return GetRuleContext<TermExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotExprContext dotExpr() {
			return GetRuleContext<DotExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DotComponentContext dotComponent() {
			return GetRuleContext<DotComponentContext>(0);
		}
		public DotExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterDotExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitDotExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDotExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DotExprContext dotExpr() {
		return dotExpr(0);
	}

	private DotExprContext dotExpr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		DotExprContext _localctx = new DotExprContext(Context, _parentState);
		DotExprContext _prevctx = _localctx;
		int _startState = 64;
		EnterRecursionRule(_localctx, 64, RULE_dotExpr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 382;
			termExpr();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 389;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new DotExprContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_dotExpr);
					State = 384;
					if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
					State = 385;
					Match(T__0);
					State = 386;
					_localctx.Field = dotComponent();
					}
					} 
				}
				State = 391;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,39,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class TermExprContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(RecParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode As() { return GetToken(RecParser.As, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypenameContext typename() {
			return GetRuleContext<TypenameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OpenParen() { return GetToken(RecParser.OpenParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExprContext expr() {
			return GetRuleContext<ExprContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CloseParen() { return GetToken(RecParser.CloseParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StructExprContext structExpr() {
			return GetRuleContext<StructExprContext>(0);
		}
		public TermExprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_termExpr; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterTermExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitTermExpr(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTermExpr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TermExprContext termExpr() {
		TermExprContext _localctx = new TermExprContext(Context, State);
		EnterRule(_localctx, 66, RULE_termExpr);
		try {
			State = 402;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 392;
				literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 393;
				Match(Identifier);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 394;
				Match(Identifier);
				State = 395;
				Match(As);
				State = 396;
				typename();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 397;
				Match(OpenParen);
				State = 398;
				expr();
				State = 399;
				Match(CloseParen);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 401;
				structExpr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Integer() { return GetToken(RecParser.Integer, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Float() { return GetToken(RecParser.Float, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(RecParser.String, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BoolLiteralContext boolLiteral() {
			return GetRuleContext<BoolLiteralContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 68, RULE_literal);
		try {
			State = 408;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Integer:
				EnterOuterAlt(_localctx, 1);
				{
				State = 404;
				Match(Integer);
				}
				break;
			case Float:
				EnterOuterAlt(_localctx, 2);
				{
				State = 405;
				Match(Float);
				}
				break;
			case String:
				EnterOuterAlt(_localctx, 3);
				{
				State = 406;
				Match(String);
				}
				break;
			case True:
			case False:
				EnterOuterAlt(_localctx, 4);
				{
				State = 407;
				boolLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BoolLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode True() { return GetToken(RecParser.True, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode False() { return GetToken(RecParser.False, 0); }
		public BoolLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.EnterBoolLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IRecListener typedListener = listener as IRecListener;
			if (typedListener != null) typedListener.ExitBoolLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IRecVisitor<TResult> typedVisitor = visitor as IRecVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BoolLiteralContext boolLiteral() {
		BoolLiteralContext _localctx = new BoolLiteralContext(Context, State);
		EnterRule(_localctx, 70, RULE_boolLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 410;
			_la = TokenStream.LA(1);
			if ( !(_la==True || _la==False) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 25: return opExpr_sempred((OpExprContext)_localctx, predIndex);
		case 28: return callExpr_sempred((CallExprContext)_localctx, predIndex);
		case 32: return dotExpr_sempred((DotExprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool opExpr_sempred(OpExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 8);
		case 1: return Precpred(Context, 7);
		case 2: return Precpred(Context, 6);
		case 3: return Precpred(Context, 5);
		case 4: return Precpred(Context, 4);
		case 5: return Precpred(Context, 2);
		}
		return true;
	}
	private bool callExpr_sempred(CallExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6: return Precpred(Context, 2);
		}
		return true;
	}
	private bool dotExpr_sempred(DotExprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7: return Precpred(Context, 2);
		}
		return true;
	}

	private static int[] _serializedATN = {
		4,1,60,413,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		1,0,5,0,74,8,0,10,0,12,0,77,9,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,86,8,1,
		1,2,1,2,1,2,5,2,91,8,2,10,2,12,2,94,9,2,1,2,5,2,97,8,2,10,2,12,2,100,9,
		2,1,2,1,2,1,2,1,3,1,3,1,3,5,3,108,8,3,10,3,12,3,111,9,3,1,4,1,4,1,4,5,
		4,116,8,4,10,4,12,4,119,9,4,1,4,1,4,3,4,123,8,4,1,5,1,5,1,5,1,6,1,6,4,
		6,130,8,6,11,6,12,6,131,1,7,1,7,1,7,1,8,3,8,138,8,8,1,8,1,8,1,8,1,8,1,
		8,1,8,5,8,146,8,8,10,8,12,8,149,9,8,1,8,1,8,3,8,153,8,8,3,8,155,8,8,1,
		8,1,8,1,9,1,9,1,9,1,10,3,10,163,8,10,1,10,1,10,1,10,1,10,1,10,1,10,5,10,
		171,8,10,10,10,12,10,174,9,10,3,10,176,8,10,1,10,1,10,3,10,180,8,10,1,
		10,1,10,1,11,1,11,1,11,1,11,1,11,1,12,1,12,5,12,191,8,12,10,12,12,12,194,
		9,12,1,12,1,12,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,
		208,8,13,1,14,1,14,1,14,1,15,1,15,1,15,1,16,1,16,1,16,1,16,3,16,220,8,
		16,1,17,1,17,1,17,1,17,3,17,226,8,17,1,18,1,18,1,18,1,18,1,19,1,19,1,19,
		1,19,1,20,1,20,3,20,238,8,20,1,21,1,21,1,21,3,21,243,8,21,1,21,1,21,1,
		21,1,22,3,22,249,8,22,1,22,1,22,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
		4,23,261,8,23,11,23,12,23,262,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
		3,23,273,8,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,5,23,282,8,23,10,23,12,
		23,285,9,23,3,23,287,8,23,1,23,1,23,3,23,291,8,23,3,23,293,8,23,1,24,1,
		24,1,25,1,25,1,25,1,25,3,25,301,8,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,
		1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,5,25,320,8,25,10,25,
		12,25,323,9,25,1,26,1,26,1,26,1,26,1,27,1,27,5,27,331,8,27,10,27,12,27,
		334,9,27,1,27,1,27,1,28,1,28,1,28,1,28,1,28,3,28,343,8,28,1,28,1,28,1,
		28,1,28,5,28,349,8,28,10,28,12,28,352,9,28,3,28,354,8,28,1,28,5,28,357,
		8,28,10,28,12,28,360,9,28,1,29,1,29,1,29,1,29,4,29,366,8,29,11,29,12,29,
		367,1,29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,1,31,1,31,3,31,380,8,31,1,
		32,1,32,1,32,1,32,1,32,1,32,5,32,388,8,32,10,32,12,32,391,9,32,1,33,1,
		33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,3,33,403,8,33,1,34,1,34,1,34,
		1,34,3,34,409,8,34,1,35,1,35,1,35,0,3,50,56,64,36,0,2,4,6,8,10,12,14,16,
		18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
		66,68,70,0,9,1,0,17,18,3,0,12,12,37,37,48,49,2,0,36,36,38,38,2,0,4,8,54,
		54,1,0,50,51,2,0,9,11,52,52,1,0,48,49,2,0,50,50,52,52,1,0,39,40,444,0,
		75,1,0,0,0,2,85,1,0,0,0,4,87,1,0,0,0,6,104,1,0,0,0,8,112,1,0,0,0,10,124,
		1,0,0,0,12,127,1,0,0,0,14,133,1,0,0,0,16,137,1,0,0,0,18,158,1,0,0,0,20,
		162,1,0,0,0,22,183,1,0,0,0,24,188,1,0,0,0,26,207,1,0,0,0,28,209,1,0,0,
		0,30,212,1,0,0,0,32,215,1,0,0,0,34,225,1,0,0,0,36,227,1,0,0,0,38,231,1,
		0,0,0,40,237,1,0,0,0,42,239,1,0,0,0,44,248,1,0,0,0,46,292,1,0,0,0,48,294,
		1,0,0,0,50,300,1,0,0,0,52,324,1,0,0,0,54,328,1,0,0,0,56,337,1,0,0,0,58,
		361,1,0,0,0,60,371,1,0,0,0,62,379,1,0,0,0,64,381,1,0,0,0,66,402,1,0,0,
		0,68,408,1,0,0,0,70,410,1,0,0,0,72,74,3,2,1,0,73,72,1,0,0,0,74,77,1,0,
		0,0,75,73,1,0,0,0,75,76,1,0,0,0,76,1,1,0,0,0,77,75,1,0,0,0,78,86,3,20,
		10,0,79,86,3,16,8,0,80,86,3,22,11,0,81,86,3,42,21,0,82,86,3,8,4,0,83,86,
		3,4,2,0,84,86,3,10,5,0,85,78,1,0,0,0,85,79,1,0,0,0,85,80,1,0,0,0,85,81,
		1,0,0,0,85,82,1,0,0,0,85,83,1,0,0,0,85,84,1,0,0,0,86,3,1,0,0,0,87,88,5,
		42,0,0,88,92,3,46,23,0,89,91,5,44,0,0,90,89,1,0,0,0,91,94,1,0,0,0,92,90,
		1,0,0,0,92,93,1,0,0,0,93,98,1,0,0,0,94,92,1,0,0,0,95,97,3,2,1,0,96,95,
		1,0,0,0,97,100,1,0,0,0,98,96,1,0,0,0,98,99,1,0,0,0,99,101,1,0,0,0,100,
		98,1,0,0,0,101,102,5,19,0,0,102,103,5,42,0,0,103,5,1,0,0,0,104,109,5,44,
		0,0,105,106,5,1,0,0,106,108,5,44,0,0,107,105,1,0,0,0,108,111,1,0,0,0,109,
		107,1,0,0,0,109,110,1,0,0,0,110,7,1,0,0,0,111,109,1,0,0,0,112,113,5,33,
		0,0,113,117,3,6,3,0,114,116,3,2,1,0,115,114,1,0,0,0,116,119,1,0,0,0,117,
		115,1,0,0,0,117,118,1,0,0,0,118,122,1,0,0,0,119,117,1,0,0,0,120,121,5,
		19,0,0,121,123,5,33,0,0,122,120,1,0,0,0,122,123,1,0,0,0,123,9,1,0,0,0,
		124,125,5,34,0,0,125,126,3,6,3,0,126,11,1,0,0,0,127,129,5,29,0,0,128,130,
		5,44,0,0,129,128,1,0,0,0,130,131,1,0,0,0,131,129,1,0,0,0,131,132,1,0,0,
		0,132,13,1,0,0,0,133,134,5,44,0,0,134,135,3,46,23,0,135,15,1,0,0,0,136,
		138,3,12,6,0,137,136,1,0,0,0,137,138,1,0,0,0,138,139,1,0,0,0,139,140,5,
		28,0,0,140,141,5,44,0,0,141,147,5,57,0,0,142,143,3,14,7,0,143,144,5,2,
		0,0,144,146,1,0,0,0,145,142,1,0,0,0,146,149,1,0,0,0,147,145,1,0,0,0,147,
		148,1,0,0,0,148,154,1,0,0,0,149,147,1,0,0,0,150,152,3,14,7,0,151,153,5,
		2,0,0,152,151,1,0,0,0,152,153,1,0,0,0,153,155,1,0,0,0,154,150,1,0,0,0,
		154,155,1,0,0,0,155,156,1,0,0,0,156,157,5,58,0,0,157,17,1,0,0,0,158,159,
		5,44,0,0,159,160,3,46,23,0,160,19,1,0,0,0,161,163,3,12,6,0,162,161,1,0,
		0,0,162,163,1,0,0,0,163,164,1,0,0,0,164,165,5,23,0,0,165,166,5,44,0,0,
		166,175,5,55,0,0,167,172,3,18,9,0,168,169,5,2,0,0,169,171,3,18,9,0,170,
		168,1,0,0,0,171,174,1,0,0,0,172,170,1,0,0,0,172,173,1,0,0,0,173,176,1,
		0,0,0,174,172,1,0,0,0,175,167,1,0,0,0,175,176,1,0,0,0,176,177,1,0,0,0,
		177,179,5,56,0,0,178,180,3,46,23,0,179,178,1,0,0,0,179,180,1,0,0,0,180,
		181,1,0,0,0,181,182,3,24,12,0,182,21,1,0,0,0,183,184,5,27,0,0,184,185,
		5,44,0,0,185,186,5,53,0,0,186,187,3,46,23,0,187,23,1,0,0,0,188,192,5,57,
		0,0,189,191,3,26,13,0,190,189,1,0,0,0,191,194,1,0,0,0,192,190,1,0,0,0,
		192,193,1,0,0,0,193,195,1,0,0,0,194,192,1,0,0,0,195,196,5,58,0,0,196,25,
		1,0,0,0,197,208,3,38,19,0,198,208,3,42,21,0,199,208,3,32,16,0,200,208,
		3,36,18,0,201,208,3,30,15,0,202,208,3,28,14,0,203,208,5,24,0,0,204,208,
		5,25,0,0,205,208,3,24,12,0,206,208,3,48,24,0,207,197,1,0,0,0,207,198,1,
		0,0,0,207,199,1,0,0,0,207,200,1,0,0,0,207,201,1,0,0,0,207,202,1,0,0,0,
		207,203,1,0,0,0,207,204,1,0,0,0,207,205,1,0,0,0,207,206,1,0,0,0,208,27,
		1,0,0,0,209,210,5,31,0,0,210,211,3,48,24,0,211,29,1,0,0,0,212,213,5,26,
		0,0,213,214,3,24,12,0,214,31,1,0,0,0,215,216,5,20,0,0,216,217,3,48,24,
		0,217,219,3,24,12,0,218,220,3,34,17,0,219,218,1,0,0,0,219,220,1,0,0,0,
		220,33,1,0,0,0,221,222,5,21,0,0,222,226,3,24,12,0,223,224,5,21,0,0,224,
		226,3,32,16,0,225,221,1,0,0,0,225,223,1,0,0,0,226,35,1,0,0,0,227,228,5,
		22,0,0,228,229,3,48,24,0,229,230,3,24,12,0,230,37,1,0,0,0,231,232,3,48,
		24,0,232,233,5,53,0,0,233,234,3,48,24,0,234,39,1,0,0,0,235,238,5,41,0,
		0,236,238,3,48,24,0,237,235,1,0,0,0,237,236,1,0,0,0,238,41,1,0,0,0,239,
		240,7,0,0,0,240,242,5,44,0,0,241,243,3,46,23,0,242,241,1,0,0,0,242,243,
		1,0,0,0,243,244,1,0,0,0,244,245,5,53,0,0,245,246,3,40,20,0,246,43,1,0,
		0,0,247,249,5,44,0,0,248,247,1,0,0,0,248,249,1,0,0,0,249,250,1,0,0,0,250,
		251,3,46,23,0,251,45,1,0,0,0,252,293,3,6,3,0,253,254,5,55,0,0,254,255,
		3,46,23,0,255,256,5,56,0,0,256,293,1,0,0,0,257,258,5,55,0,0,258,260,3,
		46,23,0,259,261,3,46,23,0,260,259,1,0,0,0,261,262,1,0,0,0,262,260,1,0,
		0,0,262,263,1,0,0,0,263,264,1,0,0,0,264,265,5,56,0,0,265,293,1,0,0,0,266,
		267,5,50,0,0,267,293,3,46,23,0,268,269,5,59,0,0,269,272,3,46,23,0,270,
		271,5,3,0,0,271,273,5,45,0,0,272,270,1,0,0,0,272,273,1,0,0,0,273,274,1,
		0,0,0,274,275,5,60,0,0,275,293,1,0,0,0,276,277,5,23,0,0,277,286,5,55,0,
		0,278,283,3,44,22,0,279,280,5,2,0,0,280,282,3,44,22,0,281,279,1,0,0,0,
		282,285,1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,287,1,0,0,0,285,283,
		1,0,0,0,286,278,1,0,0,0,286,287,1,0,0,0,287,288,1,0,0,0,288,290,5,56,0,
		0,289,291,3,46,23,0,290,289,1,0,0,0,290,291,1,0,0,0,291,293,1,0,0,0,292,
		252,1,0,0,0,292,253,1,0,0,0,292,257,1,0,0,0,292,266,1,0,0,0,292,268,1,
		0,0,0,292,276,1,0,0,0,293,47,1,0,0,0,294,295,3,50,25,0,295,49,1,0,0,0,
		296,297,6,25,-1,0,297,298,7,1,0,0,298,301,3,50,25,3,299,301,3,52,26,0,
		300,296,1,0,0,0,300,299,1,0,0,0,301,321,1,0,0,0,302,303,10,8,0,0,303,304,
		7,2,0,0,304,320,3,50,25,9,305,306,10,7,0,0,306,307,7,3,0,0,307,320,3,50,
		25,8,308,309,10,6,0,0,309,310,7,4,0,0,310,320,3,50,25,7,311,312,10,5,0,
		0,312,313,7,5,0,0,313,320,3,50,25,6,314,315,10,4,0,0,315,316,7,6,0,0,316,
		320,3,50,25,5,317,318,10,2,0,0,318,320,7,7,0,0,319,302,1,0,0,0,319,305,
		1,0,0,0,319,308,1,0,0,0,319,311,1,0,0,0,319,314,1,0,0,0,319,317,1,0,0,
		0,320,323,1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,51,1,0,0,0,323,321,
		1,0,0,0,324,325,3,56,28,0,325,326,5,43,0,0,326,327,3,46,23,0,327,53,1,
		0,0,0,328,332,5,13,0,0,329,331,3,46,23,0,330,329,1,0,0,0,331,334,1,0,0,
		0,332,330,1,0,0,0,332,333,1,0,0,0,333,335,1,0,0,0,334,332,1,0,0,0,335,
		336,5,13,0,0,336,55,1,0,0,0,337,338,6,28,-1,0,338,339,3,64,32,0,339,358,
		1,0,0,0,340,342,10,2,0,0,341,343,3,54,27,0,342,341,1,0,0,0,342,343,1,0,
		0,0,343,344,1,0,0,0,344,353,5,55,0,0,345,350,3,48,24,0,346,347,5,2,0,0,
		347,349,3,48,24,0,348,346,1,0,0,0,349,352,1,0,0,0,350,348,1,0,0,0,350,
		351,1,0,0,0,351,354,1,0,0,0,352,350,1,0,0,0,353,345,1,0,0,0,353,354,1,
		0,0,0,354,355,1,0,0,0,355,357,5,56,0,0,356,340,1,0,0,0,357,360,1,0,0,0,
		358,356,1,0,0,0,358,359,1,0,0,0,359,57,1,0,0,0,360,358,1,0,0,0,361,362,
		5,30,0,0,362,363,3,46,23,0,363,365,5,57,0,0,364,366,3,60,30,0,365,364,
		1,0,0,0,366,367,1,0,0,0,367,365,1,0,0,0,367,368,1,0,0,0,368,369,1,0,0,
		0,369,370,5,58,0,0,370,59,1,0,0,0,371,372,5,44,0,0,372,373,5,53,0,0,373,
		374,3,48,24,0,374,61,1,0,0,0,375,380,5,44,0,0,376,377,5,44,0,0,377,378,
		5,42,0,0,378,380,3,46,23,0,379,375,1,0,0,0,379,376,1,0,0,0,380,63,1,0,
		0,0,381,382,6,32,-1,0,382,383,3,66,33,0,383,389,1,0,0,0,384,385,10,2,0,
		0,385,386,5,1,0,0,386,388,3,62,31,0,387,384,1,0,0,0,388,391,1,0,0,0,389,
		387,1,0,0,0,389,390,1,0,0,0,390,65,1,0,0,0,391,389,1,0,0,0,392,403,3,68,
		34,0,393,403,5,44,0,0,394,395,5,44,0,0,395,396,5,42,0,0,396,403,3,46,23,
		0,397,398,5,55,0,0,398,399,3,48,24,0,399,400,5,56,0,0,400,403,1,0,0,0,
		401,403,3,58,29,0,402,392,1,0,0,0,402,393,1,0,0,0,402,394,1,0,0,0,402,
		397,1,0,0,0,402,401,1,0,0,0,403,67,1,0,0,0,404,409,5,45,0,0,405,409,5,
		46,0,0,406,409,5,47,0,0,407,409,3,70,35,0,408,404,1,0,0,0,408,405,1,0,
		0,0,408,406,1,0,0,0,408,407,1,0,0,0,409,69,1,0,0,0,410,411,7,8,0,0,411,
		71,1,0,0,0,42,75,85,92,98,109,117,122,131,137,147,152,154,162,172,175,
		179,192,207,219,225,237,242,248,262,272,283,286,290,292,300,319,321,332,
		342,350,353,358,367,379,389,402,408
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
